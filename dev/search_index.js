var documenterSearchIndex = {"docs":
[{"location":"curvilinear_grids/#Curvilinear-Grids","page":"Curvilinear Grids","title":"Curvilinear Grids","text":"","category":"section"},{"location":"curvilinear_grids/","page":"Curvilinear Grids","title":"Curvilinear Grids","text":"Curvilinear grids can be achieved via a change of variables. See this post on StackExchange for more.","category":"page"},{"location":"api/discretization/","page":"Discretization","title":"Discretization","text":"CurrentModule = MethodOfLines","category":"page"},{"location":"api/discretization/#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"api/discretization/","page":"Discretization","title":"Discretization","text":"MOLFiniteDifference\nDiscreteSpace","category":"page"},{"location":"api/discretization/#MethodOfLines.MOLFiniteDifference","page":"Discretization","title":"MethodOfLines.MOLFiniteDifference","text":"MOLFiniteDifference(dxs, time=nothing;\n                    approx_order = 2, advection_scheme = UpwindScheme(),\n                    grid_align = CenterAlignedGrid(), kwargs...)\n\nA discretization algorithm.\n\nArguments\n\ndxs: A vector of pairs of parameters to the grid step in this dimension, i.e. [x=>0.2, y=>0.1].   For a non uniform rectilinear grid, replace any or all of the step sizes with the grid you'd like to   use with that variable, must be an AbstractVector but not a StepRangeLen.\ntime: Your choice of continuous variable, usually time. If time = nothing, then discretization   yeilds a NonlinearProblem. Defaults to nothing.\n\nKeyword Arguments\n\napprox_order: The order of the derivative approximation.\nadvection_scheme: The scheme to be used to discretize advection terms, i.e. first order spatial derivatives and associated coefficients. Defaults to UpwindScheme(). This is the only relevant scheme at present.\ngrid_align: The grid alignment types. See CenterAlignedGrid() and EdgeAlignedGrid().\nkwargs: Any other keyword arguments you want to pass to the ODEProblem.\n\n\n\n\n\n","category":"type"},{"location":"api/discretization/#MethodOfLines.DiscreteSpace","page":"Discretization","title":"MethodOfLines.DiscreteSpace","text":"DiscreteSpace(domain, depvars, indepvars, discretization::MOLFiniteDifference)\n\nA type that stores informations about the discretized space. It takes each independent variable defined on the space to be discretized and create a corresponding range. It then takes each dependant variable and create an array of symbolic variables to represent it in its discretized form.\n\nArguments\n\ndomain: The domain of the space.\ndepvars: The independent variables to be discretizated.\nindepvars: The independent variables.\ndiscretization: The discretization algorithm.\n\nFields\n\nū: The vector of dependant variables.\nargs: The dictionary of the operations of dependant variables and the corresponding arguments,   which include the time variable if given.\ndiscvars: The dictionary of dependant variables and the discrete symbolic representation of them.   Note that this includes the boundaries. See the example below.\ntime: The time variable. nothing for steady state problems.\nx̄: The vector of symbolic spatial variables.\naxies: The dictionary of symbolic spatial variables and their numerical discretizations.\ngrid: Same as axies if CenterAlignedGrid is used. For EdgeAlignedGrid, interpolation will need   to be defined ±dx/2 above and below the edges of the simulation domain where dx is the step size in the direction of that edge.\ndxs: The discretization symbolic spatial variables and their step sizes.\nIaxies: The dictionary of the dependant variables and their CartesianIndices of the discretization.\nIgrid: Same as axies if CenterAlignedGrid is used. For EdgeAlignedGrid, one more index will be needed for extrapolation.\nx2i: The dictionary of symbolic spatial variables their ordering.\n\nExamples\n\njulia> using MethodOfLines, DomainSets, ModelingToolkit\njulia> using MethodOfLines:DiscreteSpace\n\njulia> @parameters t x\njulia> @variables u(..)\njulia> Dt = Differential(t)\njulia> Dxx = Differential(x)^2\n\njulia> eq  = [Dt(u(t, x)) ~ Dxx(u(t, x))]\njulia> bcs = [u(0, x) ~ cos(x),\n              u(t, 0) ~ exp(-t),\n              u(t, 1) ~ exp(-t) * cos(1)]\n\njulia> domain = [t ∈ Interval(0.0, 1.0),\n                 x ∈ Interval(0.0, 1.0)]\n\njulia> dx = 0.1\njulia> discretization = MOLFiniteDifference([x => dx], t)\njulia> ds = DiscreteSpace(domain, [u(t,x).val], [x.val], discretization)\n\njulia> ds.discvars[u(t,x)]\n11-element Vector{Num}:\n  u[1](t)\n  u[2](t)\n  u[3](t)\n  u[4](t)\n  u[5](t)\n  u[6](t)\n  u[7](t)\n  u[8](t)\n  u[9](t)\n u[10](t)\n u[11](t)\n\njulia> ds.axies\nDict{Sym{Real, Base.ImmutableDict{DataType, Any}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}} with 1 entry:\n  x => 0.0:0.1:1.0\n\n\n\n\n\n","category":"type"},{"location":"tutorials/heat/#heat","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"In this tutorial we will use the symbolic interface to solve the heat equation.","category":"page"},{"location":"tutorials/heat/#Dirichlet-boundary-conditions","page":"Solving the Heat Equation","title":"Dirichlet boundary conditions","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"using OrdinaryDiffEq, ModelingToolkit, MethodOfLines, DomainSets\n# Method of Manufactured Solutions: exact solution\nu_exact = (x,t) -> exp.(-t) * cos.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ cos(x),\n        u(t, 0) ~ exp(-t),\n        u(t, 1) ~ exp(-t) * cos(1)]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n           x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [u(t, x)])\n\n# Method of lines discretization\ndx = 0.1\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys,discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, map(d -> sol[d][i], grid[u(t, x)]), label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)\nsavefig(\"plot.png\")","category":"page"},{"location":"tutorials/heat/#Neumann-boundary-conditions","page":"Solving the Heat Equation","title":"Neumann boundary conditions","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"using OrdinaryDiffEq, ModelingToolkit, MethodOfLines, DomainSets\n# Method of Manufactured Solutions: exact solution\nu_exact = (x,t) -> exp.(-t) * cos.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ cos(x),\n        Dx(u(t, 0)) ~ 0.0,\n        Dx(u(t, 1)) ~ -exp(-t) * sin(1)]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n        x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains,[t, x],[u(t, x)])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.01\norder = 2\ndiscretization = MOLFiniteDifference([x => dx],t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, map(d -> sol[d][i], grid[u(t, x)]), label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)\nsavefig(\"plot.png\")","category":"page"},{"location":"tutorials/heat/#Robin-boundary-conditions","page":"Solving the Heat Equation","title":"Robin boundary conditions","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"using ModelingToolkit, MethodOfLines, DomainSets, OrdinaryDiffEq\n# Method of Manufactured Solutions\nu_exact = (x,t) -> exp.(-t) * sin.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ sin(x),\n        u(t, -1.0) + 3Dx(u(t, -1.0)) ~ exp(-t) * (sin(-1.0) + 3cos(-1.0)),\n        u(t, 1.0) + Dx(u(t, 1.0)) ~ exp(-t) * (sin(1.0) + cos(1.0))]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n        x ∈ Interval(-1.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [u(t, x)])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.05\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, map(d -> sol[d][i], grid[u(t,x)]), label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)\nsavefig(\"plot.png\")","category":"page"},{"location":"nonuniform/#Non-Uniform-Rectilinear-Grids","page":"Non-Uniform Rectilinear Grids","title":"Non-Uniform Rectilinear Grids","text":"","category":"section"},{"location":"nonuniform/","page":"Non-Uniform Rectilinear Grids","title":"Non-Uniform Rectilinear Grids","text":"For more information on how to use a non-uniform rectilinear grid, see the docs for MOLFiniteDifference","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"CurrentModule = MethodOfLines","category":"page"},{"location":"api/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"unitindex\nparams\nIdx","category":"page"},{"location":"api/utils/#MethodOfLines.unitindex","page":"Utilities","title":"MethodOfLines.unitindex","text":"unitindex(N, j)\n\nGet a CartesianIndex of j-th canonical vector of length N.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#MethodOfLines.params","page":"Utilities","title":"MethodOfLines.params","text":"params(u, s::DiscreteSpace)\n\nFillter out the time variable and get the spatial variables of u in s.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#MethodOfLines.Idx","page":"Utilities","title":"MethodOfLines.Idx","text":"Idx(II::CartesianIndex, s::DiscreteSpace, u, indexmap)\n\nHere indexmap maps the arguments of u in s to the their ordering. Return a subindex of II that corresponds to only the spatial arguments of u.\n\n\n\n\n\n","category":"function"},{"location":"howitworks/#hiw","page":"How it Works","title":"How it works","text":"","category":"section"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"MethodOfLines.jl makes heavy use of Symbolics.jl and SymbolicUtils.jl, namely it's rule matching features to recognize terms which require particular discretizations.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"See here for the highest level overview of the algorithm.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"Given your discretization and PDESystem, we take each independent variable defined on the space to be discretized and create a corresponding range. We then take each dependant variable and create an array of symbolic variables to represent it in its discretized form. This is stored in a DiscreteSpace object, a useful abstraction.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"We recognize boundary conditions, i.e whether they are on the upper or lower ends of the domain, or periodic here, and use this information to construct the interior of the domain for each equation here. Each PDE is matched to each dependant variable in this step by which variable is highest order in each PDE, with precedance given to time derivatives. This dictates which boundary conditions reduce the size of the interior for which PDE. This is done to ensure that there will be the same number of equations as discrete variable states, so that the system of equations is balanced.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"Next, the boundary conditions are discretized, creating an equation for each point on the boundary in terms of the discretized variables, replacing any space derivatives in the direction of the boundary with their upwind finite difference expressions. This is the place to look to see how this happens.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"After that, the system of PDEs is discretized creating a finite difference equation for each point in their interior. Specific terms are recognized, and the best implemented scheme for these terms dispatched. For example advection terms are discretized with the upwind scheme. There are also special schemes for the nonlinear laplacian and spherical laplacian. See here for how this term matching occurs, note that the order the generated rules are applied is important, with more specific rules applied first to avoid their terms being matched incorrectly by more general rules.  The SymbolicUtils.jl docs are a useful companion here. See here for the practical implementation of the finite difference schemes.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"Now we have a system of equations which are either ODEs, linear, or nonlinear equations and an equal number of unknowns. See here for the system that is generated for the Brusselator at low point count. The structure of the system is simplified with ModelingToolkit.structural_simplify, and then either an ODEProblem or NonlinearProblem is returned. Under the hood, the ODEProblem generates a fast semidiscretization, written in Julia with RuntimeGeneratedFunctions. See here for an example of the generated code for the Brusselator system at low point count. ","category":"page"},{"location":"tutorials/sispde/#Steady-state-of-SIS-(suspected-infected-suspected)-reaction-diffusion-model","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Considering the following SIS reaction diffusion model:","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"leftbeginarrayl\nS_t = d_S S_x x-beta(x) fracS IS+I+gamma(x) I=0 quad 0x1 \nI_t = d_I I_x x+beta(x) fracS IS+I-gamma(x) I=0 quad 0x1 \nS_x=I_x=0 quad x=01\nendarrayright","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"where int_0^1 S(xt)+I(xt)dx = 1. S(xt) and I(xt)  denote the density of susceptible and  infected  populations at location x and time t,  d_S and d_I represent the  diffusion coefficients for susceptible and infected  individuals, and  beta(x), gamma(x) are transmission  and recovery rates at x, respectively.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"We want to solve the steady state problem (same notations for convenience):","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"leftbeginarrayl\nd_S S_x x-beta(x) fracS IS+I+gamma(x) I=0 quad 0x1 \nd_I I_x x+beta(x) fracS IS+I-gamma(x) I=0 quad 0x1 \nS_x=I_x=0 quad x=01\nendarrayright","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"where int_0^1 S(x)+I(x)dx = 1.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Note here elliptic problem has condition int_0^1 S(x)+I(x)dx = 1.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"using DifferentialEquations, ModelingToolkit, MethodOfLines, DomainSets, Plots\n\n# Parameters, variables, and derivatives\n@parameters t x\n@parameters dS dI brn ϵ\n@variables S(..) I(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# Define functions\nfunction γ(x)\n    y = x + 1.0\n    return y\nend\n\nfunction ratio(x, brn, ϵ)\n    y = brn + ϵ * sin(2 * pi * x)\n    return y\nend\n\n# 1D PDE and boundary conditions\neq = [Dt(S(t, x)) ~ dS * Dxx(S(t, x)) - ratio(x, brn, ϵ) * γ(x) * S(t, x) * I(t, x) / (S(t, x) + I(t, x)) + γ(x) * I(t, x),\n    Dt(I(t, x)) ~ dI * Dxx(I(t, x)) + ratio(x, brn, ϵ) * γ(x) * S(t, x) * I(t, x) / (S(t, x) + I(t, x)) - γ(x) * I(t, x)]\nbcs = [S(0, x) ~ 0.9 + 0.1 * sin(2 * pi * x),\n    I(0, x) ~ 0.1 + 0.1 * cos(2 * pi * x),\n    Dx(S(t, 0)) ~ 0.0,\n    Dx(S(t, 1)) ~ 0.0,\n    Dx(I(t, 0)) ~ 0.0,\n    Dx(I(t, 1)) ~ 0.0]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 10.0),\n    x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [S(t, x), I(t, x)], [dS => 0.5, dI => 0.1, brn => 3, ϵ => 0.1])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.01\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization);","category":"page"},{"location":"tutorials/sispde/#Solving-time-dependent-SIS-epidemic-model","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Solving time dependent SIS epidemic model","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"# Solving SIS reaction diffusion model\nsol = solve(prob, Tsit5(), saveat=0.2);\n\n# Retriving the results\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\nsolS = [map(d -> sol[d][i], grid[S(t, x)]) for i in 1:length(sol[t])]\nsolI = [map(d -> sol[d][i], grid[I(t, x)]) for i in 1:length(sol[t])]\nS_solution = zeros(length(discrete_t), length(discrete_x))\nI_solution = zeros(length(discrete_t), length(discrete_x))\nfor i in 1:length(discrete_t)\n    S_solution[i, :] = solS[i]\n    I_solution[i, :] = solI[i]\nend\np = surface(discrete_x, discrete_t, S_solution)\ndisplay(p)","category":"page"},{"location":"tutorials/sispde/#Solving-steady-state-problem","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Solving steady state problem","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Change the elliptic problem to steady state problem of reaction diffusion equation.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"See more solvers in Steady State Solvers · DifferentialEquations.jl","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"steadystateprob = SteadyStateProblem(prob)\nsteadystate = solve(steadystateprob, DynamicSS(Tsit5()))","category":"page"},{"location":"tutorials/sispde/#The-effect-of-human-mobility-on-endemic-size","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"The effect of human mobility on endemic size","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Set the endemic size f(d_Sd_I) = int_0^1I(xd_Sd_I)","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"function episize!(dS, dI)\n    newprob = remake(prob, p=[dS, dI, 3, 0.1])\n    steadystateprob = SteadyStateProblem(newprob)\n    state = solve(steadystateprob, DynamicSS(Tsit5()))\n    y = sum(state[100:end]) / 99\n    return y\nend\nepisize!(exp(1.0),exp(0.5))","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"References:","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Allen L J S, Bolker B M, Lou Y, et al. Asymptotic profiles of the steady states for an SIS epidemic reaction-diffusion model[J]. Discrete & Continuous Dynamical Systems, 2008, 21(1): 1.","category":"page"},{"location":"boundary_conditions/#[Boundary-Conditions](@ref-bcs)","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"What follows is a set of allowable boundary conditions, please note that this is not exhaustive - try your condition and see if it works, the handling is quite general. If it doesn't please post an issue and we'll try to support it. At the moment boundary conditions have to be supplied at the edge of the domain, but there are plans to support conditions embedded in the domain.","category":"page"},{"location":"boundary_conditions/#Definitions","page":"Boundary Conditions","title":"Definitions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using ModelingToolkit, MethodOfLines, Domainsets\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\nx_min = y_min = 0.0\n\nx_max = y_max = 1.0","category":"page"},{"location":"boundary_conditions/#Dirichlet","page":"Boundary Conditions","title":"Dirichlet","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, 0, y) ~ 1.0","category":"page"},{"location":"boundary_conditions/#Time-dependant","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, 0., y) ~ x_min*y+ 0.5t","category":"page"},{"location":"boundary_conditions/#Julia-function","page":"Boundary Conditions","title":"Julia function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, y_max) ~ sin(x)","category":"page"},{"location":"boundary_conditions/#User-defined-function","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"alpha = 9\n\nf(t,x,y) = x*y - t\n\nfunction g(x,y) \n    z = sin(x*y)+cos(y)\n    # Note that symbolic conditionals require the use of IfElse.ifelse, or registration\n    return IfElse.ifelse(z > 0, x, 1.0)\nend\n\nu(t,x,y_min) ~ f(t,x,y_min) + alpha/g(x,y_min)","category":"page"},{"location":"boundary_conditions/#Registered-User-Defined-Function","page":"Boundary Conditions","title":"Registered User Defined Function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"alpha = 9\n\nf(t,x,y) = x*y - t\n\nfunction g(x,y) \n    z = sin(x*y)+cos(y)\n    # This function must be registered as it contains a symbolic conditional\n    if z > 0\n        return x\n    else\n        return 1.0\n    end\nend\n\n@register g(x, y)\n\nu(t,x,y_min) ~ f(t,x,y_min) + alpha/g(x,y_min)","category":"page"},{"location":"boundary_conditions/#Neumann/Robin","page":"Boundary Conditions","title":"Neumann/Robin","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x_min, y) ~ 2. * Dx(v(t, x_min, y))","category":"page"},{"location":"boundary_conditions/#Time-dependant-2","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ x_min*Dy(v(t,x_min,y)) + 0.5t","category":"page"},{"location":"boundary_conditions/#Higher-order","page":"Boundary Conditions","title":"Higher order","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, 1.0) ~ sin(x) + Dyy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Time-derivative","page":"Boundary Conditions","title":"Time derivative","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Dt(u(t, x_min, y)) ~ 0.2","category":"page"},{"location":"boundary_conditions/#User-defined-function-2","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"function f(u, v)\n    (u + Dyy(v) - Dy(u))/(1 + v)\nend\n\nDyy(u(t, x, y_min)) ~ f(u(t, x, y_min), v(t, x, y_min)) + 1","category":"page"},{"location":"boundary_conditions/#lhs","page":"Boundary Conditions","title":"0 lhs","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"0 ~ u(t, x, y_max) - Dy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Periodic","page":"Boundary Conditions","title":"Periodic","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ u(t, x_max, y)\n\nv(t, x, y_max) ~ u(t, x_max, y)","category":"page"},{"location":"get_grid/#get*discrete-(@id-get*grid)","page":"Grid and Solution Retrieval","title":"getdiscrete (@id getgrid)","text":"","category":"section"},{"location":"get_grid/","page":"Grid and Solution Retrieval","title":"Grid and Solution Retrieval","text":"MethodOfLines.jl exports a helper function get_discrete, which returns a Dict with the keys being the independent and dependent variables, and the values their corresponding discrete grid, and discretized variables used in the discretization. It is used as following:","category":"page"},{"location":"get_grid/","page":"Grid and Solution Retrieval","title":"Grid and Solution Retrieval","text":"grid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\n# Retrieve shaped solution\nu_sol = [map(d -> sol[d][i], grid[u(t, x)]) for i in 1:length(sol[t])]","category":"page"},{"location":"generated/bruss_ode_eqs/#brusssys","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"Here's the generated system of equations for the Brusselator, with dx = dy = 1/4","category":"page"},{"location":"generated/bruss_ode_eqs/#Equations-for-u","page":"Generated ODE system for the Brusselator Equation","title":"Equations for u","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"[Differential(t)(u[2, 2](t)) ~ 1.0 + 160.0u[3, 2](t) + 160.0u[5, 2](t) - 320.0u[2, 2](t) + 160.0u[2, 3](t) + 160.0u[2, 5](t) - 320.0u[2, 2](t) + (u[2, 2](t)^2)*v[2, 2](t) - 4.4u[2, 2](t), \nDifferential(t)(u[3, 2](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[4, 2](t) - 320.0u[3, 2](t) + 160.0u[3, 3](t) + 160.0u[3, 5](t) - 320.0u[3, 2](t) + (u[3, 2](t)^2)*v[3, 2](t) - 4.4u[3, 2](t), \nDifferential(t)(u[4, 2](t)) ~ 1.0 + 160.0u[4, 3](t) + 160.0u[4, 5](t) - 320.0u[4, 2](t) + 160.0u[3, 2](t) + 160.0u[5, 2](t) - 320.0u[4, 2](t) + (u[4, 2](t)^2)*v[4, 2](t) - 4.4u[4, 2](t), \nDifferential(t)(u[5, 2](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[4, 2](t) - 320.0u[5, 2](t) + 160.0u[5, 3](t) + 160.0u[5, 5](t) - 320.0u[5, 2](t) + (u[5, 2](t)^2)*v[5, 2](t) - 4.4u[5, 2](t), \nDifferential(t)(u[2, 3](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[2, 4](t) - 320.0u[2, 3](t) + 160.0u[3, 3](t) + 160.0u[5, 3](t) - 320.0u[2, 3](t) + (u[2, 3](t)^2)*v[2, 3](t) - 4.4u[2, 3](t), \nDifferential(t)(u[3, 3](t)) ~ 1.0 + 160.0u[2, 3](t) + 160.0u[4, 3](t) - 320.0u[3, 3](t) + 160.0u[3, 2](t) + 160.0u[3, 4](t) - 320.0u[3, 3](t) + (u[3, 3](t)^2)*v[3, 3](t) - 4.4u[3, 3](t), \nDifferential(t)(u[4, 3](t)) ~ 1.0 + 160.0u[3, 3](t) + 160.0u[5, 3](t) - 320.0u[4, 3](t) + 160.0u[4, 2](t) + 160.0u[4, 4](t) - 320.0u[4, 3](t) + (u[4, 3](t)^2)*v[4, 3](t) - 4.4u[4, 3](t), \nDifferential(t)(u[5, 3](t)) ~ 1.0 + 160.0u[2, 3](t) + 160.0u[4, 3](t) - 320.0u[5, 3](t) + 160.0u[5, 2](t) + 160.0u[5, 4](t) - 320.0u[5, 3](t) + (u[5, 3](t)^2)*v[5, 3](t) - 4.4u[5, 3](t), \nDifferential(t)(u[2, 4](t)) ~ 1.0 + 160.0u[3, 4](t) + 160.0u[5, 4](t) - 320.0u[2, 4](t) + 160.0u[2, 3](t) + 160.0u[2, 5](t) - 320.0u[2, 4](t) + (u[2, 4](t)^2)*v[2, 4](t) - 4.4u[2, 4](t), \nDifferential(t)(u[3, 4](t)) ~ 1.0 + 160.0u[2, 4](t) + 160.0u[4, 4](t) - 320.0u[3, 4](t) + 160.0u[3, 3](t) + 160.0u[3, 5](t) - 320.0u[3, 4](t) + (u[3, 4](t)^2)*v[3, 4](t) - 4.4u[3, 4](t), \nDifferential(t)(u[4, 4](t)) ~ 1.0 + 160.0u[4, 3](t) + 160.0u[4, 5](t) - 320.0u[4, 4](t) + 160.0u[3, 4](t) + 160.0u[5, 4](t) - 320.0u[4, 4](t) + (u[4, 4](t)^2)*v[4, 4](t) - 4.4u[4, 4](t), \nDifferential(t)(u[5, 4](t)) ~ 1.0 + 160.0u[2, 4](t) + 160.0u[4, 4](t) - 320.0u[5, 4](t) + 160.0u[5, 3](t) + 160.0u[5, 5](t) - 320.0u[5, 4](t) + (u[5, 4](t)^2)*v[5, 4](t) - 4.4u[5, 4](t), \nDifferential(t)(u[2, 5](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[2, 4](t) - 320.0u[2, 5](t) + 160.0u[3, 5](t) + 160.0u[5, 5](t) - 320.0u[2, 5](t) + (u[2, 5](t)^2)*v[2, 5](t) - 4.4u[2, 5](t), \nDifferential(t)(u[3, 5](t)) ~ 1.0 + 160.0u[2, 5](t) + 160.0u[4, 5](t) - 320.0u[3, 5](t) + 160.0u[3, 2](t) + 160.0u[3, 4](t) - 320.0u[3, 5](t) + (u[3, 5](t)^2)*v[3, 5](t) - 4.4u[3, 5](t), \nDifferential(t)(u[4, 5](t)) ~ 1.0 + 160.0u[3, 5](t) + 160.0u[5, 5](t) - 320.0u[4, 5](t) + 160.0u[4, 2](t) + 160.0u[4, 4](t) - 320.0u[4, 5](t) + (u[4, 5](t)^2)*v[4, 5](t) - 4.4u[4, 5](t), \nDifferential(t)(u[5, 5](t)) ~ 1.0 + 160.0u[2, 5](t) + 160.0u[4, 5](t) - 320.0u[5, 5](t) + 160.0u[5, 2](t) + 160.0u[5, 4](t) - 320.0u[5, 5](t) + (u[5, 5](t)^2)*v[5, 5](t) - 4.4u[5, 5](t)] ","category":"page"},{"location":"generated/bruss_ode_eqs/#Equations-for-v","page":"Generated ODE system for the Brusselator Equation","title":"Equations for v","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"[Differential(t)(v[2, 2](t)) ~ 160.0v[2, 3](t) + 160.0v[2, 5](t) - 320.0v[2, 2](t) + 160.0v[3, 2](t) + 160.0v[5, 2](t) - 320.0v[2, 2](t) + 3.4u[2, 2](t) - (u[2, 2](t)^2)*v[2, 2](t), \nDifferential(t)(v[3, 2](t)) ~ 160.0v[2, 2](t) + 160.0v[4, 2](t) - 320.0v[3, 2](t) + 160.0v[3, 3](t) + 160.0v[3, 5](t) - 320.0v[3, 2](t) + 3.4u[3, 2](t) - (u[3, 2](t)^2)*v[3, 2](t), \nDifferential(t)(v[4, 2](t)) ~ 160.0v[3, 2](t) + 160.0v[5, 2](t) - 320.0v[4, 2](t) + 160.0v[4, 3](t) + 160.0v[4, 5](t) - 320.0v[4, 2](t) + 3.4u[4, 2](t) - (u[4, 2](t)^2)*v[4, 2](t), \nDifferential(t)(v[5, 2](t)) ~ 160.0v[5, 3](t) + 160.0v[5, 5](t) - 320.0v[5, 2](t) + 160.0v[2, 2](t) + 160.0v[4, 2](t) - 320.0v[5, 2](t) + 3.4u[5, 2](t) - (u[5, 2](t)^2)*v[5, 2](t), \nDifferential(t)(v[2, 3](t)) ~ 160.0v[2, 2](t) + 160.0v[2, 4](t) - 320.0v[2, 3](t) + 160.0v[3, 3](t) + 160.0v[5, 3](t) - 320.0v[2, 3](t) + 3.4u[2, 3](t) - (u[2, 3](t)^2)*v[2, 3](t), \nDifferential(t)(v[3, 3](t)) ~ 160.0v[3, 2](t) + 160.0v[3, 4](t) - 320.0v[3, 3](t) + 160.0v[2, 3](t) + 160.0v[4, 3](t) - 320.0v[3, 3](t) + 3.4u[3, 3](t) - (u[3, 3](t)^2)*v[3, 3](t), \nDifferential(t)(v[4, 3](t)) ~ 160.0v[3, 3](t) + 160.0v[5, 3](t) - 320.0v[4, 3](t) + 160.0v[4, 2](t) + 160.0v[4, 4](t) - 320.0v[4, 3](t) + 3.4u[4, 3](t) - (u[4, 3](t)^2)*v[4, 3](t), \nDifferential(t)(v[5, 3](t)) ~ 160.0v[2, 3](t) + 160.0v[4, 3](t) - 320.0v[5, 3](t) + 160.0v[5, 2](t) + 160.0v[5, 4](t) - 320.0v[5, 3](t) + 3.4u[5, 3](t) - (u[5, 3](t)^2)*v[5, 3](t), \nDifferential(t)(v[2, 4](t)) ~ 160.0v[2, 3](t) + 160.0v[2, 5](t) - 320.0v[2, 4](t) + 160.0v[3, 4](t) + 160.0v[5, 4](t) - 320.0v[2, 4](t) + 3.4u[2, 4](t) - (u[2, 4](t)^2)*v[2, 4](t), \nDifferential(t)(v[3, 4](t)) ~ 160.0v[2, 4](t) + 160.0v[4, 4](t) - 320.0v[3, 4](t) + 160.0v[3, 3](t) + 160.0v[3, 5](t) - 320.0v[3, 4](t) + 3.4u[3, 4](t) - (u[3, 4](t)^2)*v[3, 4](t), \nDifferential(t)(v[4, 4](t)) ~ 160.0v[3, 4](t) + 160.0v[5, 4](t) - 320.0v[4, 4](t) + 160.0v[4, 3](t) + 160.0v[4, 5](t) - 320.0v[4, 4](t) + 3.4u[4, 4](t) - (u[4, 4](t)^2)*v[4, 4](t), \nDifferential(t)(v[5, 4](t)) ~ 160.0v[2, 4](t) + 160.0v[4, 4](t) - 320.0v[5, 4](t) + 160.0v[5, 3](t) + 160.0v[5, 5](t) - 320.0v[5, 4](t) + 3.4u[5, 4](t) - (u[5, 4](t)^2)*v[5, 4](t), \nDifferential(t)(v[2, 5](t)) ~ 160.0v[2, 2](t) + 160.0v[2, 4](t) - 320.0v[2, 5](t) + 160.0v[3, 5](t) + 160.0v[5, 5](t) - 320.0v[2, 5](t) + 3.4u[2, 5](t) - (u[2, 5](t)^2)*v[2, 5](t), \nDifferential(t)(v[3, 5](t)) ~ 160.0v[2, 5](t) + 160.0v[4, 5](t) - 320.0v[3, 5](t) + 160.0v[3, 2](t) + 160.0v[3, 4](t) - 320.0v[3, 5](t) + 3.4u[3, 5](t) - (u[3, 5](t)^2)*v[3, 5](t), \nDifferential(t)(v[4, 5](t)) ~ 160.0v[4, 2](t) + 160.0v[4, 4](t) - 320.0v[4, 5](t) + 160.0v[3, 5](t) + 160.0v[5, 5](t) - 320.0v[4, 5](t) + 3.4u[4, 5](t) - (u[4, 5](t)^2)*v[4, 5](t), \nDifferential(t)(v[5, 5](t)) ~ 160.0v[2, 5](t) + 160.0v[4, 5](t) - 320.0v[5, 5](t) + 160.0v[5, 2](t) + 160.0v[5, 4](t) - 320.0v[5, 5](t) + 3.4u[5, 5](t) - (u[5, 5](t)^2)*v[5, 5](t)]","category":"page"},{"location":"generated/bruss_ode_eqs/#Boundary-condition-Equations","page":"Generated ODE system for the Brusselator Equation","title":"Boundary condition Equations","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"u[2, 1](t) ~ u[2, 5](t), \nu[3, 1](t) ~ u[3, 5](t), \nu[4, 1](t) ~ u[4, 5](t), \nu[5, 1](t) ~ u[5, 5](t), \nu[1, 2](t) ~ u[5, 2](t), \nu[1, 3](t) ~ u[5, 3](t), \nu[1, 4](t) ~ u[5, 4](t), \nu[1, 5](t) ~ u[5, 5](t), \nu[1, 1](t) ~ 0, # Invalid corner point set to 0\nv[2, 1](t) ~ v[2, 5](t), \nv[3, 1](t) ~ v[3, 5](t), \nv[4, 1](t) ~ v[4, 5](t), \nv[5, 1](t) ~ v[5, 5](t), \nv[1, 2](t) ~ v[5, 2](t), \nv[1, 3](t) ~ v[5, 3](t), \nv[1, 4](t) ~ v[5, 4](t), \nv[1, 5](t) ~ v[5, 5](t), \nv[1, 1](t) ~ 0] # Invalid corner point set to 0","category":"page"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"On the call to ODEProblem, this code is generated.","category":"page"},{"location":"generated/bruss_code/#brusscode","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"","category":"section"},{"location":"generated/bruss_code/","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"Here's the generated julia code for the Brusselator, with dx = dy = 1/4","category":"page"},{"location":"generated/bruss_code/","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"begin\n    var\"##f#260\" = (ModelingToolkit.ODEFunctionClosure)(function (ˍ₋arg1, ˍ₋arg2, t)\n                begin\n                    var\"u[2, 2](t)\" = @inbounds(ˍ₋arg1[1])\n                    var\"u[3, 2](t)\" = @inbounds(ˍ₋arg1[2])\n                    var\"u[4, 2](t)\" = @inbounds(ˍ₋arg1[3])\n                    var\"u[5, 2](t)\" = @inbounds(ˍ₋arg1[4])\n                    var\"u[2, 3](t)\" = @inbounds(ˍ₋arg1[5])\n                    var\"u[3, 3](t)\" = @inbounds(ˍ₋arg1[6])\n                    var\"u[4, 3](t)\" = @inbounds(ˍ₋arg1[7])\n                    var\"u[5, 3](t)\" = @inbounds(ˍ₋arg1[8])\n                    var\"u[2, 4](t)\" = @inbounds(ˍ₋arg1[9])\n                    var\"u[3, 4](t)\" = @inbounds(ˍ₋arg1[10])\n                    var\"u[4, 4](t)\" = @inbounds(ˍ₋arg1[11])\n                    var\"u[5, 4](t)\" = @inbounds(ˍ₋arg1[12])\n                    var\"u[2, 5](t)\" = @inbounds(ˍ₋arg1[13])\n                    var\"u[3, 5](t)\" = @inbounds(ˍ₋arg1[14])\n                    var\"u[4, 5](t)\" = @inbounds(ˍ₋arg1[15])\n                    var\"u[5, 5](t)\" = @inbounds(ˍ₋arg1[16])\n                    var\"v[2, 2](t)\" = @inbounds(ˍ₋arg1[17])\n                    var\"v[3, 2](t)\" = @inbounds(ˍ₋arg1[18])\n                    var\"v[4, 2](t)\" = @inbounds(ˍ₋arg1[19])\n                    var\"v[5, 2](t)\" = @inbounds(ˍ₋arg1[20])\n                    var\"v[2, 3](t)\" = @inbounds(ˍ₋arg1[21])\n                    var\"v[3, 3](t)\" = @inbounds(ˍ₋arg1[22])\n                    var\"v[4, 3](t)\" = @inbounds(ˍ₋arg1[23])\n                    var\"v[5, 3](t)\" = @inbounds(ˍ₋arg1[24])\n                    var\"v[2, 4](t)\" = @inbounds(ˍ₋arg1[25])\n                    var\"v[3, 4](t)\" = @inbounds(ˍ₋arg1[26])\n                    var\"v[4, 4](t)\" = @inbounds(ˍ₋arg1[27])\n                    var\"v[5, 4](t)\" = @inbounds(ˍ₋arg1[28])\n                    var\"v[2, 5](t)\" = @inbounds(ˍ₋arg1[29])\n                    var\"v[3, 5](t)\" = @inbounds(ˍ₋arg1[30])\n                    var\"v[4, 5](t)\" = @inbounds(ˍ₋arg1[31])\n                    var\"v[5, 5](t)\" = @inbounds(ˍ₋arg1[32])\n                    begin\n                        (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(32,)}(), (+)((+)((+)((+)((+)((+)(1.0, (*)(-644.4, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)((^)(var\"u[2, 2](t)\", 2), var\"v[2, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)((^)(var\"u[3, 2](t)\", 2), var\"v[3, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[4, 2](t)\")), (*)((^)(var\"u[4, 2](t)\", 2), var\"v[4, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 2](t)\")), (*)((^)(var\"u[5, 2](t)\", 2), var\"v[5, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[2, 3](t)\", 2), var\"v[2, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[3, 3](t)\")), (*)((^)(var\"u[3, 3](t)\", 2), var\"v[3, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(-644.4, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[4, 3](t)\", 2), var\"v[4, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 3](t)\", 2), var\"v[5, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[2, 4](t)\")), (*)((^)(var\"u[2, 4](t)\", 2), var\"v[2, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(-644.4, var\"u[3, 4](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)((^)(var\"u[3, 4](t)\", 2), var\"v[3, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[4, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[4, 4](t)\", 2), var\"v[4, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 4](t)\", 2), var\"v[5, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(-644.4, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[2, 5](t)\", 2), var\"v[2, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(-644.4, var\"u[3, 5](t)\")), (*)((^)(var\"u[3, 5](t)\", 2), var\"v[3, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(-644.4, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[4, 5](t)\", 2), var\"v[4, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[5, 5](t)\")), (*)((^)(var\"u[5, 5](t)\", 2), var\"v[5, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 2](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(-640.0, var\"v[2, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 2](t)\", 2)), var\"v[2, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 2](t)\", 2)), var\"v[3, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 2](t)\"), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 5](t)\"))[Imgur](https://i.imgur.com/3kQNMI3.gifv), (*)(160.0, var\"v[5, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 2](t)\", 2)), var\"v[4, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 2](t)\", 2)), var\"v[5, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 3](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 3](t)\", 2)), var\"v[2, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[3, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 3](t)\", 2)), var\"v[3, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 3](t)\"), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 3](t)\", 2)), var\"v[4, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 3](t)\", 2)), var\"v[5, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 4](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[2, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 4](t)\", 2)), var\"v[2, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(-640.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 4](t)\", 2)), var\"v[3, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 4](t)\"), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 4](t)\", 2)), var\"v[4, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(-640.0, var\"v[5, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 4](t)\", 2)), var\"v[5, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 5](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(-640.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 5](t)\", 2)), var\"v[2, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(-640.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 5](t)\", 2)), var\"v[3, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 5](t)\"), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)(-640.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 5](t)\", 2)), var\"v[4, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 5](t)\", 2)), var\"v[5, 5](t)\")))\n                    end\n                end\n            end, function (ˍ₋out, ˍ₋arg1, ˍ₋arg2, t)\n                begin\n                    var\"u[2, 2](t)\" = @inbounds(ˍ₋arg1[1])\n                    var\"u[3, 2](t)\" = @inbounds(ˍ₋arg1[2])\n                    var\"u[4, 2](t)\" = @inbounds(ˍ₋arg1[3])\n                    var\"u[5, 2](t)\" = @inbounds(ˍ₋arg1[4])\n                    var\"u[2, 3](t)\" = @inbounds(ˍ₋arg1[5])\n                    var\"u[3, 3](t)\" = @inbounds(ˍ₋arg1[6])\n                    var\"u[4, 3](t)\" = @inbounds(ˍ₋arg1[7])\n                    var\"u[5, 3](t)\" = @inbounds(ˍ₋arg1[8])\n                    var\"u[2, 4](t)\" = @inbounds(ˍ₋arg1[9])\n                    var\"u[3, 4](t)\" = @inbounds(ˍ₋arg1[10])\n                    var\"u[4, 4](t)\" = @inbounds(ˍ₋arg1[11])\n                    var\"u[5, 4](t)\" = @inbounds(ˍ₋arg1[12])\n                    var\"u[2, 5](t)\" = @inbounds(ˍ₋arg1[13])\n                    var\"u[3, 5](t)\" = @inbounds(ˍ₋arg1[14])\n                    var\"u[4, 5](t)\" = @inbounds(ˍ₋arg1[15])\n                    var\"u[5, 5](t)\" = @inbounds(ˍ₋arg1[16])\n                    var\"v[2, 2](t)\" = @inbounds(ˍ₋arg1[17])\n                    var\"v[3, 2](t)\" = @inbounds(ˍ₋arg1[18])\n                    var\"v[4, 2](t)\" = @inbounds(ˍ₋arg1[19])\n                    var\"v[5, 2](t)\" = @inbounds(ˍ₋arg1[20])\n                    var\"v[2, 3](t)\" = @inbounds(ˍ₋arg1[21])\n                    var\"v[3, 3](t)\" = @inbounds(ˍ₋arg1[22])\n                    var\"v[4, 3](t)\" = @inbounds(ˍ₋arg1[23])\n                    var\"v[5, 3](t)\" = @inbounds(ˍ₋arg1[24])\n                    var\"v[2, 4](t)\" = @inbounds(ˍ₋arg1[25])\n                    var\"v[3, 4](t)\" = @inbounds(ˍ₋arg1[26])\n                    var\"v[4, 4](t)\" = @inbounds(ˍ₋arg1[27])\n                    var\"v[5, 4](t)\" = @inbounds(ˍ₋arg1[28])\n                    var\"v[2, 5](t)\" = @inbounds(ˍ₋arg1[29])\n                    var\"v[3, 5](t)\" = @inbounds(ˍ₋arg1[30])\n                    var\"v[4, 5](t)\" = @inbounds(ˍ₋arg1[31])\n                    var\"v[5, 5](t)\" = @inbounds(ˍ₋arg1[32])\n                    begin\n                        @inbounds begin\n                                ˍ₋out[1] = (+)((+)((+)((+)((+)((+)(1.0, (*)(-644.4, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)((^)(var\"u[2, 2](t)\", 2), var\"v[2, 2](t)\"))\n                                ˍ₋out[2] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)((^)(var\"u[3, 2](t)\", 2), var\"v[3, 2](t)\"))\n                                ˍ₋out[3] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[4, 2](t)\")), (*)((^)(var\"u[4, 2](t)\", 2), var\"v[4, 2](t)\"))\n                                ˍ₋out[4] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 2](t)\")), (*)((^)(var\"u[5, 2](t)\", 2), var\"v[5, 2](t)\"))\n                                ˍ₋out[5] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[2, 3](t)\", 2), var\"v[2, 3](t)\"))\n                                ˍ₋out[6] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[3, 3](t)\")), (*)((^)(var\"u[3, 3](t)\", 2), var\"v[3, 3](t)\"))\n                                ˍ₋out[7] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(-644.4, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[4, 3](t)\", 2), var\"v[4, 3](t)\"))\n                                ˍ₋out[8] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 3](t)\", 2), var\"v[5, 3](t)\"))\n                                ˍ₋out[9] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[2, 4](t)\")), (*)((^)(var\"u[2, 4](t)\", 2), var\"v[2, 4](t)\"))\n                                ˍ₋out[10] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(-644.4, var\"u[3, 4](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)((^)(var\"u[3, 4](t)\", 2), var\"v[3, 4](t)\"))\n                                ˍ₋out[11] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[4, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[4, 4](t)\", 2), var\"v[4, 4](t)\"))\n                                ˍ₋out[12] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 4](t)\", 2), var\"v[5, 4](t)\"))\n                                ˍ₋out[13] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(-644.4, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[2, 5](t)\", 2), var\"v[2, 5](t)\"))\n                                ˍ₋out[14] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(-644.4, var\"u[3, 5](t)\")), (*)((^)(var\"u[3, 5](t)\", 2), var\"v[3, 5](t)\"))\n                                ˍ₋out[15] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(-644.4, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[4, 5](t)\", 2), var\"v[4, 5](t)\"))\n                                ˍ₋out[16] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[5, 5](t)\")), (*)((^)(var\"u[5, 5](t)\", 2), var\"v[5, 5](t)\"))\n                                ˍ₋out[17] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 2](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(-640.0, var\"v[2, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 2](t)\", 2)), var\"v[2, 2](t)\"))\n                                ˍ₋out[18] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 2](t)\", 2)), var\"v[3, 2](t)\"))\n                                ˍ₋out[19] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 2](t)\"), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 2](t)\", 2)), var\"v[4, 2](t)\"))\n                                ˍ₋out[20] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 2](t)\", 2)), var\"v[5, 2](t)\"))\n                                ˍ₋out[21] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 3](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 3](t)\", 2)), var\"v[2, 3](t)\"))[Imgur](https://i.imgur.com/3kQNMI3.gifv)\n                                ˍ₋out[22] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[3, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 3](t)\", 2)), var\"v[3, 3](t)\"))\n                                ˍ₋out[23] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 3](t)\"), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 3](t)\", 2)), var\"v[4, 3](t)\"))\n                                ˍ₋out[24] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 3](t)\", 2)), var\"v[5, 3](t)\"))\n                                ˍ₋out[25] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 4](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[2, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 4](t)\", 2)), var\"v[2, 4](t)\"))\n                                ˍ₋out[26] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(-640.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 4](t)\", 2)), var\"v[3, 4](t)\"))\n                                ˍ₋out[27] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 4](t)\"), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 4](t)\", 2)), var\"v[4, 4](t)\"))\n                                ˍ₋out[28] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(-640.0, var\"v[5, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 4](t)\", 2)), var\"v[5, 4](t)\"))\n                                ˍ₋out[29] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 5](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(-640.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 5](t)\", 2)), var\"v[2, 5](t)\"))\n                                ˍ₋out[30] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(-640.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 5](t)\", 2)), var\"v[3, 5](t)\"))\n                                ˍ₋out[31] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 5](t)\"), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)(-640.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 5](t)\", 2)), var\"v[4, 5](t)\"))\n                                ˍ₋out[32] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 5](t)\", 2)), var\"v[5, 5](t)\"))\n                                nothing\n                            end\n                    end\n                end\n            end)\n    var\"##tgrad#261\" = nothing\n    var\"##jac#262\" = nothing\n    M = UniformScaling{Bool}(true)\n    ODEFunction{true}(var\"##f#260\", jac = var\"##jac#262\", tgrad = var\"##tgrad#261\", mass_matrix = M, jac_prototype = nothing, syms = [Symbol(\"u[2, 2](t)\"), Symbol(\"u[3, 2](t)\"), Symbol(\"u[4, 2](t)\"), Symbol(\"u[5, 2](t)\"), Symbol(\"u[2, 3](t)\"), Symbol(\"u[3, 3](t)\"), Symbol(\"u[4, 3](t)\"), Symbol(\"u[5, 3](t)\"), Symbol(\"u[2, 4](t)\"), Symbol(\"u[3, 4](t)\"), Symbol(\"u[4, 4](t)\"), Symbol(\"u[5, 4](t)\"), Symbol(\"u[2, 5](t)\"), Symbol(\"u[3, 5](t)\"), Symbol(\"u[4, 5](t)\"), Symbol(\"u[5, 5](t)\"), Symbol(\"v[2, 2](t)\"), Symbol(\"v[3, 2](t)\"), Symbol(\"v[4, 2](t)\"), Symbol(\"v[5, 2](t)\"), Symbol(\"v[2, 3](t)\"), Symbol(\"v[3, 3](t)\"), Symbol(\"v[4, 3](t)\"), Symbol(\"v[5, 3](t)\"), Symbol(\"v[2, 4](t)\"), Symbol(\"v[3, 4](t)\"), Symbol(\"v[4, 4](t)\"), Symbol(\"v[5, 4](t)\"), Symbol(\"v[2, 5](t)\"), Symbol(\"v[3, 5](t)\"), Symbol(\"v[4, 5](t)\"), Symbol(\"v[5, 5](t)\")], indepsym = :t)\nend","category":"page"},{"location":"devnotes/#Notes-for-developers","page":"Notes for Developers: Implement a Scheme","title":"Notes for developers","text":"","category":"section"},{"location":"devnotes/#Getting-started","page":"Notes for Developers: Implement a Scheme","title":"Getting started","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"First, fork the repo and clone it locally.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Then, type in the REPL","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"julia>] dev /path/to/your/repo\njulia>] activate MethodOfLines","category":"page"},{"location":"devnotes/#Overview","page":"Notes for Developers: Implement a Scheme","title":"Overview","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"MethodOfLines.jl makes heavy use of Symbolics.jl and SymbolicUtils.jl, especially the replacement rules from the latter.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Take a look at src/discretization/MOL_discretization.jl to get a high level overview of how the discretization works. A more consise description can be found here. Feel free to post an issue if you would like help understanding anything, or want to know developer opinions on the best way to go about implementing something.","category":"page"},{"location":"devnotes/#Adding-new-finite-difference-schemes","page":"Notes for Developers: Implement a Scheme","title":"Adding new finite difference schemes","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"If you know of a finite difference scheme which is better than what is currently implemented, please first post an issue with a link to a paper.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"A replacement rule is generated for each term which has a more specific higher stability/accuracy finite difference scheme than the general central difference, which represents a base case.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Take a look at src/discretization/generate_finite_difference_rules.jl to see where the replacement rules are generated. Implemented schemes can be found in /src/discretization/schemes. Have a look at some of the already implemented examples there; read about the @rule macro from SymbolicUtils.jl, if you haven't already. Note that the order that the rules are applied is important; there may be schemes that are applied first that are special cases of more general rules, for example the sphrical laplacian is a special case of the nonlinear laplacian.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"First terms are split, isolating particular cases. Then, rules are generated and applied.  ","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Identify a rule which will match your case, then write a function that will handle how to apply that scheme for each index in the interior, for each combination of independant and dependant variables. ","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"This should be a function of the current index II::CartesianIndex, an independent variable x which represents the direction of the derivative, and a dependent variable u, which is the variable of which the derivative will be taken. The discrete representation of u is found in s.discvars[u], which is an array with the same number of spatial dimensions as u, each index a symbol representing the discretized u at that index. Using this, and cartesian index offsets from II, create a finite difference/volume symbolic expression for the approximation of the derivative form you are trying to discretize. This should be returned.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"For example, the following is a simple rule and function that would discretize derivatives of each dependent variable uin each dependent variable x with the second order central difference approximation:","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"#TODO: Add handling for cases where II is close to the boundaries\n#TODO: Handle periodic boundary conditions\n#TODO: Handle nonuniformly discretized `x`\nfunction second_order_central_difference(II::CartesianIndex, s::DiscreteSpace, u, x)\n    # Get which place `x` appears in `u`'s arguments\n    j = x2i(s, u, x)\n\n    # Get a CartesianIndex of unit length that points in the direction of `x` e.g. CartesianIndex((1, 0, 0))\n    I1 = unitindex(ndims(u, s), j) \n\n    discu = s.discvars[u]\n    expr = (discu[II + I1] - discu[II - I1])/s.dx[x]\n\n    return expr\nend\n\n# Note that indexmap is used along with the function `Idx` to create an equivalent index for the discrete form of `u`,\n# which may have a different number of dimensions to `II`\nfunction generate_central_difference_rules(II::CartesianIndex, s::DiscreteSpace, terms::Vector{<:Term}, indexmap::Dict)\n    rules = [[@rule Differential(x)(u) => second_order_central_difference(Idx(II, s, u, indexmap), s, u, x) for x in, params(u, x)] for u in depvars]\n\n    rules = reduce(vcat, rules)\n\n    # Parse the rules in to pairs that can be used with `substitute`, this can be copy pasted.\n    rule_pairs = []\n    for t in terms\n        for r in rules\n            if r(t) !== nothing\n                push!(rule_pairs, t => r(t))\n            end\n        end\n    end\n    return rule_pairs\nend","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Initially, don't worry if your scheme is only implemented for specific approximation orders, it is sufficient just to warn when the requested approximation order does not match that supplied by the scheme. We can work in future pull requests to generalize the scheme to higher approximation orders, where possible.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Finally, include your rules in the vector of rules to be used to replace terms in the PDE at this index, found here:","category":"page"},{"location":"devnotes/#Inspecting-generated-code","page":"Notes for Developers: Implement a Scheme","title":"Inspecting generated code","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"To get the generated code for your system, use code = ODEFunctionExpr(prob), or MethodOfLines.generate_code(pdesys, discretization, \"my_generated_code_filename.jl\"), which will create a file called my_generated_code_filename.jl in pwd(). This can be useful to find errors in the discretization, but note that it is not recommended to use this code directly, calling solve(prob, AppropriateSolver()) will handle this for you.","category":"page"},{"location":"tutorials/brusselator/#brusselator","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/brusselator/#Using-the-Brusselator-PDE-as-an-example","page":"Tutorial","title":"Using the Brusselator PDE as an example","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"The Brusselator PDE is defined as follows:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nfracpartial upartial t = 1 + u^2v - 44u + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2) + f(x y t)\nfracpartial vpartial t = 34u - u^2v + alpha(fracpartial^2 vpartial x^2 + fracpartial^2 vpartial y^2)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"where","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"f(x y t) = begincases\n5  quad textif  (x-03)^2+(y-06)^2  01^2 text and  t  11 \n0  quad textelse\nendcases","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"and the initial conditions are","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x y 0) = 22cdot (y(1-y))^32 \nv(x y 0) = 27cdot (x(1-x))^32\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"with the periodic boundary condition","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x+1yt) = u(xyt) \nu(xy+1t) = u(xyt)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"on a timespan of t in 0115.","category":"page"},{"location":"tutorials/brusselator/#Solving-with-MethodOfLines","page":"Tutorial","title":"Solving with MethodOfLines","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"With ModelingToolkit.jl, we first symbolicaly define the system, see also the docs for PDESystem:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\n∇²(u) = Dxx(u) + Dyy(u)\n\nbrusselator_f(x, y, t) = (((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.\n\nx_min = y_min = t_min = 0.0\nx_max = y_max = 1.0\nt_max = 11.5\n\nα = 10.\n\nu0(x,y,t) = 22(y*(1-y))^(3/2)\nv0(x,y,t) = 27(x*(1-x))^(3/2)\n\neq = [Dt(u(x,y,t)) ~ 1. + v(x,y,t)*u(x,y,t)^2 - 4.4*u(x,y,t) + α*∇²(u(x,y,t)) + brusselator_f(x, y, t),\n       Dt(v(x,y,t)) ~ 3.4*u(x,y,t) - v(x,y,t)*u(x,y,t)^2 + α*∇²(v(x,y,t))]\n\ndomains = [x ∈ Interval(x_min, x_max),\n              y ∈ Interval(y_min, y_max),\n              t ∈ Interval(t_min, t_max)]\n\n# Periodic BCs\nbcs = [u(x,y,0) ~ u0(x,y,0),\n       u(0,y,t) ~ u(1,y,t),\n       u(x,0,t) ~ u(x,1,t),\n\n       v(x,y,0) ~ v0(x,y,0),\n       v(0,y,t) ~ v(1,y,t),\n       v(x,0,t) ~ v(x,1,t)] \n\n@named pdesys = PDESystem(eq,bcs,domains,[x,y,t],[u(x,y,t),v(x,y,t)])","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For a list of limitations constraining which systems will work, see here","category":"page"},{"location":"tutorials/brusselator/#Method-of-lines-discretization","page":"Tutorial","title":"Method of lines discretization","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Then, we create the discretization, leaving the time dimension undiscretized by supplying t as an argument. Optionally, all dimensions can be discretized in this step, just remove the argument t and supply t=>dt in the dxs. See here for more information on the MOLFiniteDifference constructor arguments and options.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"N = 32\n\ndx = (x_max-x_min)/N\ndy = (y_max-y_min)/N\n\norder = 2\n\ndiscretization = MOLFiniteDifference([x=>dx, y=>dy], t, approx_order=order, grid_align=center_align)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Next, we discretize the system, converting the PDESystem in to an ODEProblem or NonlinearProblem.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"# Convert the PDE problem into an ODE problem\nprintln(\"Discretization:\")\n@time prob = discretize(pdesys,discretization)","category":"page"},{"location":"tutorials/brusselator/#Solving-the-problem","page":"Tutorial","title":"Solving the problem","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Now your problem can be solved with an appropriate ODE solver, or Nonlinear solver if you have not supplied a time dimension in the MOLFiniteDifference constructor. Include these solvers with using OrdinaryDiffEq or using NonlinearSolve, then call sol = solve(prob, AppropriateSolver()) or sol = NonlinearSolve.solve(prob, AppropriateSolver()). For more information on the available solvers, see the docs for DifferentialEquations.jl, NonlinearSolve.jl and SteadyStateDiffEq.jl. Tsit5() is a good first choice of solver for many problems.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"println(\"Solve:\")\n@time sol = solve(prob, TRBDF2(), saveat=0.1)","category":"page"},{"location":"tutorials/brusselator/#Extracting-results","page":"Tutorial","title":"Extracting results","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"To retrieve your solution, for example for u, use sol[u]. To get the time axis, use sol.t.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Due to current limitations in the sol interface, above 1 discretized dimension the result must be manually reshaped to correctly display the result, best done with the help of the get_discrete helper function. Here is an example of how to do this:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"grid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_y = grid[y]\ndiscrete_t = sol[t]\n\nsolu = [map(d -> sol[d][i], grid[u(x, y, t)]) for i in 1:length(sol[t])]\nsolv = [map(d -> sol[d][i], grid[v(x, y, t)]) for i in 1:length(sol[t])]","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"The result after plotting an animation:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For u:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"using Plots\nanim = @animate for k in 1:length(discrete_t)\n    heatmap(solu[k][2:end, 2:end], title=\"$(discrete_t[k])\") # 2:end since end = 1, periodic condition\nend\ngif(anim, \"plots/Brusselator2Dsol_u.gif\", fps = 8)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"(Image: Brusselator2Dsol_u)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For v:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"anim = @animate for k in 1:length(discrete_t)\n    heatmap(solv[k][2:end, 2:end], title=\"$(discrete_t[k])\")\nend\ngif(anim, \"plots/Brusselator2Dsol_v.gif\", fps = 8)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"(Image: Brusselator2Dsol_v)","category":"page"},{"location":"MOLFiniteDifference/#molfd","page":"MOLFiniteDifference","title":"Discretization","text":"","category":"section"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"struct MOLFiniteDifference{G} <: DiffEqBase.AbstractDiscretization\n    dxs\n    time\n    approx_order::Int\n    upwind_order::Int\n    grid_align::G\nend\n\n# Constructors. If no order is specified, both upwind and centered differences will be 2nd order\nfunction MOLFiniteDifference(dxs, time=nothing; approx_order = 2, upwind_order = 1, grid_align=CenterAlignedGrid())\n    \n    if approx_order % 2 != 0\n        @warn \"Discretization approx_order must be even, rounding up to $(approx_order+1)\"\n    end\n    @assert approx_order >= 1 \"approx_order must be at least 1\"\n    @assert upwind_order >= 1 \"upwind_order must be at least 1\"\n    \n    return MOLFiniteDifference{typeof(grid_align)}(dxs, time, approx_order, upwind_order, grid_align)\nend","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"eq = [your system of equations, see examples for possibilities]\nbcs = [your boundary conditions, see examples for possibilities]\n\ndomain = [your domain, a vector of Intervals i.e. x ∈ Interval(x_min, x_max)]\n\n@named pdesys = PDESystem(eq, bcs, domains, [t, x, y], [u(t, x, y)])\n\ndiscretization = MOLFiniteDifference(dxs, \n                                      <your choice of continuous variable, usually time>; \n                                      upwind_order = <Currently unstable at any value other than 1>, \n                                      approx_order = <Order of derivative approximation, starting from 2> \n                                      grid_align = <your grid type choice>)\nprob = discretize(pdesys, discretization)","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Where dxs is a vector of pairs of parameters to the grid step in this dimension, i.e. [x=>0.2, y=>0.1]. For a non uniform rectilinear grid, replace any or all of the step sizes with the grid you'd like to use with that variable, must be an AbstractVector but not a StepRangeLen.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Note that the second argument to MOLFiniteDifference is optional, all parameters can be discretized if all required boundary conditions are specified.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Currently supported grid types: center_align and edge_align. Edge align will give better accuracy with Neumann boundary conditions.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"center_align: naive grid, starting from lower boundary, ending on upper boundary with step of dx","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"edge_align: offset grid, set halfway between the points that would be generated with center_align, with extra points at either end that are above and below the supremum and infimum by dx/2. This improves accuracy for Neumann BCs.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Any unrecognized keyword arguments will be passed to the ODEProblem constructor, see its documentation for available options.","category":"page"},{"location":"tutorials/icbc_sampled/#Initial-and-Boundary-Conditions-with-sampled/measured-Data","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"","category":"section"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Initial and boundary conditions are sometimes applied with measured data that is itself pre-discretized. In order to use such data it is recommended to leverage Interpolations.jl, or DataInterpolations.jl, for better dealing with possibly noisy data (currently limited to 1D). To create a callable effectively continuous function, for example (from the Interpolations.jl docs):","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"1D:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"using Interpolations\n\nA_x = 1.:2.:40.\nA = [log10(x) for x in A_x]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp1 = scale(itp, A_x)\nsitp1(3.) # exactly log10(3.)\nsitp1(3.5) # approximately log10(3.5)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Multidimensional:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"using Interpolations \n\nA_x1 = 1:.1:10\nA_x2 = 1:.5:20\nf(x1, x2) = log10(x1+x2)\nA = [f(x1,x2) for x1 in A_x1, x2 in A_x2]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp2 = scale(itp, A_x1, A_x2)\nsitp2(5., 10.) # exactly log10(5 + 10)\nsitp2(5.6, 7.1) # approximately log10(5.6 + 7.1)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Then, register the functions with ModelingToolkit:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"sitp1_f(x) = sitp1(x)\nsitp2_f(x, y) = sitp2(x, y)\n@register_symbolic sitp1_f(y)\n@register_symbolic sitp2_f(x, y)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Then as a BC or IC:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"bcs = [u(0, x, y) ~ sitp2_f(x, y),\n       u(t, 0, y) ~ sitp1_f(y),\n       ...\n       ]","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Note that the measured data need not be measured on the same grid as will be generated for the discretization in MethodOfLines.jl, as long as it is defined upon the whole simulation domain it will be automatically re-sampled.","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"If you are using an edge_align grid, your interpolation will need to be defined ±dx/2 above and below the edges of the simulation domain where dx is the step size in the direction of that edge. Extrapolation may prove useful here.","category":"page"},{"location":"tutorials/heatss/#Steady-State-Heat-Equation-No-Time-Dependance-NonlinearProblem","page":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","title":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","text":"","category":"section"},{"location":"tutorials/heatss/","page":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","title":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","text":"Sometimes it is desirable to solve an equation that has no time evolution, such as the steady state heat equation:","category":"page"},{"location":"tutorials/heatss/","page":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","title":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","text":"using ModelingToolkit, MethodOfLines, DomainSets, NonlinearSolve\n\n@parameters x y\n@variables u(..)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\neq = Dxx(u(x, y)) + Dyy(u(x, y)) ~ 0\n\nbcs = [u(0, y) ~ x * y,\n       u(1, y) ~ x * y,\n       u(x, 0) ~ x * y,\n       u(x, 1) ~ x * y]\n\n\n# Space and time domains\ndomains = [x ∈ Interval(0.0, 1.0),\n           y ∈ Interval(0.0, 1.0)]\n\n@named pdesys = PDESystem([eq], bcs, domains, [x, y], [u(x, y)])\n\ndx = 0.1\ndy = 0.1\n\n# Note that we pass in `nothing` for the time variable `t` here since we\n# are creating a stationary problem without a dependence on time, only space.\ndiscretization = MOLFiniteDifference([x => dx, y => dy], nothing, approx_order=2)\n\nprob = discretize(pdesys, discretization)\nsol = NonlinearSolve.solve(prob, NewtonRaphson())\n\ngrid = get_discrete(pdesys, discretization)\n\nu_sol = map(d -> sol[d], grid[u(x, y)])\n\nusing Plots\n\nheatmap(grid[x], grid[y], u_sol, xlabel=\"x values\", ylabel=\"y values\",\n        title=\"Steady State Heat Equation\")","category":"page"},{"location":"tutorials/params/#Adding-parameters","page":"Adding parameters","title":"Adding parameters","text":"","category":"section"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"We can also build up more complicated systems with multiple dependent variables and parameters as follows","category":"page"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n@parameters t x\n@parameters Dn, Dp\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\neqs  = [Dt(u(t,x)) ~ Dn * Dxx(u(t,x)) + u(t,x)*v(t,x), \n        Dt(v(t,x)) ~ Dp * Dxx(v(t,x)) - u(t,x)*v(t,x)]\nbcs = [u(0,x) ~ sin(pi*x/2),\n       v(0,x) ~ sin(pi*x/2),\n       u(t,0) ~ 0.0, Dx(u(t,1)) ~ 0.0,\n       v(t,0) ~ 0.0, Dx(v(t,1)) ~ 0.0]\n\ndomains = [t ∈ Interval(0.0,1.0),\n           x ∈ Interval(0.0,1.0)]\n\n@named pdesys = PDESystem(eqs,bcs,domains,[t,x],[u(t,x),v(t,x)],[Dn=>0.5, Dp=>2])\n\ndiscretization = MOLFiniteDifference([x=>0.1],t)\n\nprob = discretize(pdesys,discretization) # This gives an ODEProblem since it's time-dependent\n\nsol = solve(prob,Tsit5())\n\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\n\nusing Plots\n\nanim = @animate for i in 1:length(t)\n    p1 = plot(discrete_x, map(d -> sol[d][i], grid[u(t, x)]), label=\"u, t=$(discrete_t[i])[1:9] \"; legend=false, xlabel=\"x\",ylabel=\"u\",ylim=[0,1])\n    p2 = plot(discrete_x, map(d -> sol[d][i], grid[v(t, x)]), label=\"v, t=$(discrete_t[i])\"; legend=false, xlabel=\"x\", ylabel=\"v\",ylim=[0, 1])\n    plot(p1, p2)\nend\ngif(anim, \"plot.gif\",fps=30)","category":"page"},{"location":"tutorials/params/#Remake-with-different-parameter-values","page":"Adding parameters","title":"Remake with different parameter values","text":"","category":"section"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"The system does not need to be re-discretized every time we want to plot with different parameters, the system can be remade with new parameters with remake. See the ModelingToolkit.jl docs for more ways to manipulate a prob post discretization.","category":"page"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n@parameters t x\n@parameters Dn, Dp\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\neqs  = [Dt(u(t, x)) ~ Dn * Dxx(u(t, x)) + u(t, x)*v(t,x),\n        Dt(v(t, x)) ~ Dp * Dxx(v(t, x)) - u(t, x)*v(t,x)]\nbcs = [u(0, x) ~ sin(pi*x/2),\n       v(0, x) ~ sin(pi*x/2),\n       u(t, 0) ~ 0.0, Dx(u(t, 1)) ~ 0.0,\n       v(t, 0) ~ 0.0, Dx(v(t, 1)) ~ 0.0]\n\ndomains = [t ∈ Interval(0.0, 1.0),\n           x ∈ Interval(0.0, 1.0)]\n\n@named pdesys = PDESystem(eqs, bcs, domains,[t, x], [u(t, x), v(t, x)], [Dn=>0.5, Dp=>2.0])\n\ndiscretization = MOLFiniteDifference([x=>0.1], t)\n\nprob = discretize(pdesys,discretization) # This gives an ODEProblem since it's time-dependent\n\nsols = []\nfor (Dnval, Dpval) in zip(rand(10), rand(10))\n    newprob = remake(prob, p = [Dnval, Dpval])\n    push!(sols, solve(newprob, Tsit5()));\nend\n\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\n\nusing Plots\nfor (j, sol) in enumerate(sols)\n    discrete_t = sol[t]\n    anim = @animate for i in 1:length(discrete_t)\n        p1 = plot(discrete_x, map(d -> sol[d][i], grid[u(t, x)]), label=\"u, t=$(discrete_t[i])\"; legend=false, xlabel=\"x\",ylabel=\"u\",ylim=[0,1])\n        p2 = plot(discrete_x, map(d -> sol[d][i], grid[v(t, x)]), label=\"v, t=$(discrete_t[i])\"; legend=false, xlabel=\"x\", ylabel=\"v\",ylim=[0, 1])\n        plot(p1, p2)\n    end\n    gif(anim, \"plot_$j.gif\",fps=10)\nend\n","category":"page"},{"location":"#index","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"MethodOfLines.jl is a Julia package for automated finite difference discretization of symbolicaly-defined PDEs in N dimensions.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"It uses symbolic expressions for systems of partial differential equations as defined with ModelingToolkit.jl, and Interval from DomainSets.jl to define the space(time) over which the simulation runs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"The package's handling is quite general, it is recommended to try out your system of equations and post an issue if you run in to trouble. If you want to solve it, we want to support it.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Issues with questions on usage are also welcome as they help us improve the docs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"See here for a full tutorial, involving the Brusselator equation.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Allowable terms in the system include, but are not limited to","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Advection\nDiffusion\nReaction\nNonlinear Diffusion\nSpherical laplacian\nAny Julia function of the symbolic parameters/dependant variables and other parameters in the environment that's defined on the whole domain. Note that more complicated functions may require registration with @register, see the ModelingToolkit.jl docs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Boundary conditions include, but are not limited to:","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Dirichlet\nNeumann (can also include time derivative)\nRobin (can also include time derivative)\nPeriodic\nAny function, subject to the assumptions below","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"At the moment the centered difference, upwind difference, nonlinear laplacian and spherical laplacian schemes are implemented. If you know of a scheme with better stability or accuracy in any specific case, please post an issue with a link to a paper.","category":"page"},{"location":"#limitations","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"Known Limitations","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"At the moment the package is able to discretize almost any system, with some assumptions listed below","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"That the grid is cartesian.\nThat the equation is first order in time.\nBoundary conditions in time are supplied as initial conditions, not at the end of the simulation interal. If your system requires a final condition, please use a change of variables to rectify this. This is unlikely to change due to upstream constraints.\nIntergral equations are not supported.\nThat dependant variables always have the same argument signature, except in BCs.\nThat periodic boundary conditions are of the simple form u(t, x_min) ~ u(t, x_max), or the same with lhs and rhs reversed. Note that this generalises to higher dimensions.\nThat boundary conditions do not contain references to derivatives which are not in the direction of the boundary, except in time.\nThat initial conditions are of the form u(...) ~ ..., and don't reference the initial time derivative.\nThat simple derivative terms are purely of a dependant variable, for example Dx(u(t,x,y)) is allowed but Dx(u(t,x,y)*v(t,x,y)), Dx(u(t,x)+1) or Dx(f(u(t,x))) are not. As a workaround please expand such terms with the product rule and use the linearity of the derivative operator, or define a new auxiliary dependant variable by adding an equation for it like eqs = [Differential(x)(w(t,x))~ ... , w(t,x) ~ v(t,x)*u(t,x)], along with appropriate BCs/ICs. An exception to this is if the differential is a nonlinear or spherical laplacian, in which case only the innermost argument should be wrapped.\nThat odd order derivatives do not multiply or divide each other. A workaround is to wrap all but one derivative per term in an auxiliary variable, such as dxu(x, t) ~ Differential(x)(u(x, t)).","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"The performance hit from auxiliary variables should be negligable due to a structural simplification step.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"If any of these limitations are a problem for you please post an issue and we will prioritize removing them. If you discover a limitation that isn't listed here, pleae post an issue with example code.","category":"page"},{"location":"#If-you-have-any-usage-questions-or-feature-requests,-please-post-an-issue","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"If you have any usage questions or feature requests, please post an issue","text":"","category":"section"}]
}
