var documenterSearchIndex = {"docs":
[{"location":"curvilinear_grids/#Curvilinear-Grids","page":"Curvilinear Grids","title":"Curvilinear Grids","text":"","category":"section"},{"location":"curvilinear_grids/","page":"Curvilinear Grids","title":"Curvilinear Grids","text":"Curvilinear grids can be achieved via a change of variables. See this post on StackExchange for more.","category":"page"},{"location":"api/discretization/","page":"Discretization","title":"Discretization","text":"CurrentModule = MethodOfLines","category":"page"},{"location":"api/discretization/#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"api/discretization/","page":"Discretization","title":"Discretization","text":"MOLFiniteDifference\nDiscreteSpace","category":"page"},{"location":"api/discretization/#MethodOfLines.MOLFiniteDifference","page":"Discretization","title":"MethodOfLines.MOLFiniteDifference","text":"MOLFiniteDifference(dxs, time=nothing;\n                    approx_order = 2, advection_scheme = UpwindScheme(),\n                    grid_align = CenterAlignedGrid(), kwargs...)\n\nA discretization algorithm.\n\nArguments\n\ndxs: A vector of pairs of parameters to the grid step in this dimension, i.e. [x=>0.2, y=>0.1].   For a non uniform rectilinear grid, replace any or all of the step sizes with the grid you'd like to   use with that variable, must be an AbstractVector but not a StepRangeLen.\ntime: Your choice of continuous variable, usually time. If time = nothing, then discretization   yeilds a NonlinearProblem. Defaults to nothing.\n\nKeyword Arguments\n\napprox_order: The order of the derivative approximation.\nadvection_scheme: The scheme to be used to discretize advection terms, i.e. first order spatial derivatives and associated coefficients. Defaults to UpwindScheme(). WENOScheme() is also available, and is more stable and accurate at the cost of complexity.\ngrid_align: The grid alignment types. See CenterAlignedGrid() and EdgeAlignedGrid().\nuse_ODAE: If true, the discretization will use the ODAEproblem constructor.   Defaults to false.\nkwargs: Any other keyword arguments you want to pass to the ODEProblem.\n\n\n\n\n\n","category":"type"},{"location":"api/discretization/#MethodOfLines.DiscreteSpace","page":"Discretization","title":"MethodOfLines.DiscreteSpace","text":"DiscreteSpace(domain, depvars, indepvars, discretization::MOLFiniteDifference)\n\nA type that stores informations about the discretized space. It takes each independent variable defined on the space to be discretized and create a corresponding range. It then takes each dependant variable and create an array of symbolic variables to represent it in its discretized form.\n\nArguments\n\ndomain: The domain of the space.\nvars: A VariableMap object that contains the dependant and independent variables and   other important values.\ndiscretization: The discretization algorithm.\n\nProperties\n\nū: The vector of dependant variables.\nargs: The dictionary of the operations of dependant variables and the corresponding arguments,   which include the time variable if given.\ndiscvars: The dictionary of dependant variables and the discrete symbolic representation of them.   Note that this includes the boundaries. See the example below.\ntime: The time variable. nothing for steady state problems.\nx̄: The vector of symbolic spatial variables.\naxies: The dictionary of symbolic spatial variables and their numerical discretizations.\ngrid: Same as axies if CenterAlignedGrid is used. For EdgeAlignedGrid, interpolation will need   to be defined ±dx/2 above and below the edges of the simulation domain where dx is the step size in the direction of that edge.\ndxs: The discretization symbolic spatial variables and their step sizes.\nIaxies: The dictionary of the dependant variables and their CartesianIndices of the discretization.\nIgrid: Same as axies if CenterAlignedGrid is used. For EdgeAlignedGrid, one more index will be needed for extrapolation.\nx2i: The dictionary of symbolic spatial variables their ordering.\n\nExamples\n\njulia> using MethodOfLines, DomainSets, ModelingToolkit\njulia> using MethodOfLines:DiscreteSpace\n\njulia> @parameters t x\njulia> @variables u(..)\njulia> Dt = Differential(t)\njulia> Dxx = Differential(x)^2\n\njulia> eq  = [Dt(u(t, x)) ~ Dxx(u(t, x))]\njulia> bcs = [u(0, x) ~ cos(x),\n              u(t, 0) ~ exp(-t),\n              u(t, 1) ~ exp(-t) * cos(1)]\n\njulia> domain = [t ∈ Interval(0.0, 1.0),\n                 x ∈ Interval(0.0, 1.0)]\n\njulia> dx = 0.1\njulia> discretization = MOLFiniteDifference([x => dx], t)\njulia> ds = DiscreteSpace(domain, [u(t,x).val], [x.val], discretization)\n\njulia> ds.discvars[u(t,x)]\n11-element Vector{Num}:\n  u[1](t)\n  u[2](t)\n  u[3](t)\n  u[4](t)\n  u[5](t)\n  u[6](t)\n  u[7](t)\n  u[8](t)\n  u[9](t)\n u[10](t)\n u[11](t)\n\njulia> ds.axies\nDict{Sym{Real, Base.ImmutableDict{DataType, Any}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}} with 1 entry:\n  x => 0.0:0.1:1.0\n\n\n\n\n\n","category":"type"},{"location":"solutions/#sol","page":"Solution Interface - PDESolutions","title":"Solution Retrieval - PDESolutions","text":"","category":"section"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"MethodOfLines automatically wraps the ODESolution that results from its generated ODEProblem in  a PDESolution object, reshaping it and providing a convenient interface for accessing your results, as well as interpolations.","category":"page"},{"location":"solutions/#Solution-Retrieval","page":"Solution Interface - PDESolutions","title":"Solution Retrieval","text":"","category":"section"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"For example, for a PDESystem such as the following:","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"@named pdesys = PDESystem(eqs, bcs, domains, [t, x, y], [u(t, x, y), v((t, x, y))])","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"after the solve:","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"sol = solve(prob)","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"You can access the solutions for u and v like this:","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"solu = sol[u(t, x, y)]\nsolv = sol[v(t, x, y)]","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"Note that the result in this case will be a 3D Array, dimensions matching the order that they appear in the arguent signature of the variable. The time variable must appear either first or last in the  arguments, or an error will be thrown.","category":"page"},{"location":"solutions/#Grid-Retrieval","page":"Solution Interface - PDESolutions","title":"Grid Retrieval","text":"","category":"section"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"To access the discretized axes for the independent variables, simply index the solution with the independent variable itself:","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"disc_t = sol[t]\ndisc_x = sol[x]\ndisc_y = sol[y]","category":"page"},{"location":"solutions/#Interpolations","page":"Solution Interface - PDESolutions","title":"Interpolations","text":"","category":"section"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"To access an interpolation of the solution, call the sol object:","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"#Interpolated solution of `u` at t = 0.4, x = 1.7, y = 2.6\nu_interp = sol(0.4, 1.7, 2.6, dv = u(t, x, y))","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"To retrieve an interpolation in all dependent variables as a vector, leave off the dv argument.  Be sure to supply a value for every independent variable in the order that they appear in sol.ivs. The vector is in the order of sol.dvs.","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"uv_interp = sol(0.4, 1.7, 2.6)","category":"page"},{"location":"solutions/#Original-solution","page":"Solution Interface - PDESolutions","title":"Original solution","text":"","category":"section"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"The original ODESolution is stored in sol.original_sol.","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"To avoid wrapping entirely, use the wrap keyword argument to solve:","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"sol = solve(prob, Tsit5(); wrap = Val(false))","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"> typeof(sol)\nODESolution","category":"page"},{"location":"solutions/","page":"Solution Interface - PDESolutions","title":"Solution Interface - PDESolutions","text":"This is useful where speed is important, but the shape of the solution is not.","category":"page"},{"location":"nonuniform/#Non-Uniform-Rectilinear-Grids","page":"Non-Uniform Rectilinear Grids","title":"Non-Uniform Rectilinear Grids","text":"","category":"section"},{"location":"nonuniform/","page":"Non-Uniform Rectilinear Grids","title":"Non-Uniform Rectilinear Grids","text":"For more information on how to use a non-uniform rectilinear grid, see the docs for MOLFiniteDifference","category":"page"},{"location":"tutorials/heat/#heat","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"In this tutorial we will use the symbolic interface to solve the heat equation.","category":"page"},{"location":"tutorials/heat/#Dirichlet-boundary-conditions","page":"Solving the Heat Equation","title":"Dirichlet boundary conditions","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"using OrdinaryDiffEq, ModelingToolkit, MethodOfLines, DomainSets\n# Method of Manufactured Solutions: exact solution\nu_exact = (x,t) -> exp.(-t) * cos.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ cos(x),\n        u(t, 0) ~ exp(-t),\n        u(t, 1) ~ exp(-t) * cos(1)]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n           x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [u(t, x)])\n\n# Method of lines discretization\ndx = 0.1\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys,discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\nsolu = sol[u(t, x)]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, solu[i, :], label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(discrete_x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)","category":"page"},{"location":"tutorials/heat/#Neumann-boundary-conditions","page":"Solving the Heat Equation","title":"Neumann boundary conditions","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"using OrdinaryDiffEq, ModelingToolkit, MethodOfLines, DomainSets\n# Method of Manufactured Solutions: exact solution\nu_exact = (x,t) -> exp.(-t) * cos.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ cos(x),\n        Dx(u(t, 0)) ~ 0.0,\n        Dx(u(t, 1)) ~ -exp(-t) * sin(1)]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n        x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains,[t, x],[u(t, x)])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.01\norder = 2\ndiscretization = MOLFiniteDifference([x => dx],t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\n\nsolu = sol[u(t, x)]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, solu[i, :], label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(discrete_x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)","category":"page"},{"location":"tutorials/heat/#Robin-boundary-conditions","page":"Solving the Heat Equation","title":"Robin boundary conditions","text":"","category":"section"},{"location":"tutorials/heat/","page":"Solving the Heat Equation","title":"Solving the Heat Equation","text":"using ModelingToolkit, MethodOfLines, DomainSets, OrdinaryDiffEq\n# Method of Manufactured Solutions\nu_exact = (x,t) -> exp.(-t) * sin.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ sin(x),\n        u(t, -1.0) + 3Dx(u(t, -1.0)) ~ exp(-t) * (sin(-1.0) + 3cos(-1.0)),\n        u(t, 1.0) + Dx(u(t, 1.0)) ~ exp(-t) * (sin(1.0) + cos(1.0))]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n        x ∈ Interval(-1.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [u(t, x)])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.05\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\n\nsolu = sol[u(t, x)]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, solu[i, :], label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(discrete_x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"CurrentModule = MethodOfLines","category":"page"},{"location":"api/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"unitindex\nparams\nIdx","category":"page"},{"location":"api/utils/#MethodOfLines.unitindex","page":"Utilities","title":"MethodOfLines.unitindex","text":"unitindex(N, j)\n\nGet a unit CartesianIndex in dimension j of length N.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#MethodOfLines.params","page":"Utilities","title":"MethodOfLines.params","text":"params(u, s::DiscreteSpace)\n\nFillter out the time variable and get the spatial variables of u in s.\n\n\n\n\n\n","category":"function"},{"location":"api/utils/#MethodOfLines.Idx","page":"Utilities","title":"MethodOfLines.Idx","text":"Idx(II::CartesianIndex, s::DiscreteSpace, u, indexmap)\n\nHere indexmap maps the arguments of u in s to the their ordering. Return a subindex of II that corresponds to only the spatial arguments of u.\n\n\n\n\n\n","category":"function"},{"location":"howitworks/#hiw","page":"How it Works","title":"How it works","text":"","category":"section"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"MethodOfLines.jl makes heavy use of Symbolics.jl and SymbolicUtils.jl, namely it's rule matching features to recognize terms which require particular discretizations.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"See here for the highest level overview of the algorithm.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"Given your discretization and PDESystem, we take each independent variable defined on the space to be discretized and create a corresponding range. We then take each dependant variable and create an array of symbolic variables to represent it in its discretized form. This is stored in a DiscreteSpace object, a useful abstraction.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"We recognize boundary conditions, i.e whether they are on the upper or lower ends of the domain, or periodic here, and use this information to construct the interior of the domain for each equation here. Each PDE is matched to each dependant variable in this step by which variable is highest order in each PDE, with precedance given to time derivatives. This dictates which boundary conditions reduce the size of the interior for which PDE. This is done to ensure that there will be the same number of equations as discrete variable states, so that the system of equations is balanced.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"Next, the boundary conditions are discretized, creating an equation for each point on the boundary in terms of the discretized variables, replacing any space derivatives in the direction of the boundary with their upwind finite difference expressions. This is the place to look to see how this happens.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"After that, the system of PDEs is discretized creating a finite difference equation for each point in their interior. Specific terms are recognized, and the best implemented scheme for these terms dispatched. For example advection terms are discretized with the upwind scheme. There are also special schemes for the nonlinear laplacian and spherical laplacian. See here for how this term matching occurs, note that the order the generated rules are applied is important, with more specific rules applied first to avoid their terms being matched incorrectly by more general rules.  The SymbolicUtils.jl docs are a useful companion here. See here for the practical implementation of the finite difference schemes.","category":"page"},{"location":"howitworks/","page":"How it Works","title":"How it Works","text":"Now we have a system of equations which are either ODEs, linear, or nonlinear equations and an equal number of unknowns. See here for the system that is generated for the Brusselator at low point count. The structure of the system is simplified with ModelingToolkit.structural_simplify, and then either an ODEProblem or NonlinearProblem is returned. Under the hood, the ODEProblem generates a fast semidiscretization, written in Julia with RuntimeGeneratedFunctions. See here for an example of the generated code for the Brusselator system at low point count. ","category":"page"},{"location":"advection_schemes/#adschemes","page":"Advection Schemes","title":"Advection Schemes","text":"","category":"section"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"Used as a keyword argument advection_scheme to MOLFiniteDifference.","category":"page"},{"location":"advection_schemes/#Upwind-Scheme","page":"Advection Schemes","title":"Upwind Scheme","text":"","category":"section"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"UpwindScheme(approx_order = 1)","category":"page"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"Changes the direction of the stencil based on the sign of the coefficient of the odd order derivative to be discretized. Scheme order can be increased by changing the approx_order keyword argument. For more information, see Wikipedia","category":"page"},{"location":"advection_schemes/#WENO-Scheme-of-Jiang-and-Shu","page":"Advection Schemes","title":"WENO Scheme of Jiang and Shu","text":"","category":"section"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"WENOScheme(epsilon = 1e-6)","category":"page"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"A more stable scheme, 5th order accurate, which is a weighted sum of several different schemes, weighted based on the curvature of the solution at the point in question. More stable and tolerant of discontinuities, at the cost of solve complexity.","category":"page"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"epsilonis a quantity used to prevent vanishing denominators in the scheme, defaults to 1e-6. Problems with a lower magnitude solution will benefit from a smaller value.","category":"page"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"Problems which require this scheme may also benefit from a Strong-Stability-Preserving (SSP) solver.","category":"page"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"Problems with first order derivatives which multiply one another will need to use this scheme over the upwind scheme.","category":"page"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"Supports only first order derivatives, other odd order derivatives are unsupported with this scheme. At present does not support Nonuniform grids, though this is a planned feature.","category":"page"},{"location":"advection_schemes/","page":"Advection Schemes","title":"Advection Schemes","text":"Specified on pages 8-9 of this document","category":"page"},{"location":"tutorials/sispde/#Steady-state-of-SIS-(suspected-infected-suspected)-reaction-diffusion-model","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Considering the following SIS reaction diffusion model:","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"leftbeginarrayl\nS_t = d_S S_x x-beta(x) fracS IS+I+gamma(x) I=0 quad 0x1 \nI_t = d_I I_x x+beta(x) fracS IS+I-gamma(x) I=0 quad 0x1 \nS_x=I_x=0 quad x=01\nendarrayright","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"where int_0^1 S(xt)+I(xt)dx = 1. S(xt) and I(xt)  denote the density of susceptible and  infected  populations at location x and time t,  d_S and d_I represent the  diffusion coefficients for susceptible and infected  individuals, and  beta(x), gamma(x) are transmission  and recovery rates at x, respectively.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"We want to solve the steady state problem (same notations for convenience):","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"leftbeginarrayl\nd_S S_x x-beta(x) fracS IS+I+gamma(x) I=0 quad 0x1 \nd_I I_x x+beta(x) fracS IS+I-gamma(x) I=0 quad 0x1 \nS_x=I_x=0 quad x=01\nendarrayright","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"where int_0^1 S(x)+I(x)dx = 1.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Note here elliptic problem has condition int_0^1 S(x)+I(x)dx = 1.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"using DifferentialEquations, ModelingToolkit, MethodOfLines, DomainSets, Plots\n\n# Parameters, variables, and derivatives\n@parameters t x\n@parameters dS dI brn ϵ\n@variables S(..) I(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# Define functions\nfunction γ(x)\n    y = x + 1.0\n    return y\nend\n\nfunction ratio(x, brn, ϵ)\n    y = brn + ϵ * sin(2 * pi * x)\n    return y\nend\n\n# 1D PDE and boundary conditions\neq = [Dt(S(t, x)) ~ dS * Dxx(S(t, x)) - ratio(x, brn, ϵ) * γ(x) * S(t, x) * I(t, x) / (S(t, x) + I(t, x)) + γ(x) * I(t, x),\n    Dt(I(t, x)) ~ dI * Dxx(I(t, x)) + ratio(x, brn, ϵ) * γ(x) * S(t, x) * I(t, x) / (S(t, x) + I(t, x)) - γ(x) * I(t, x)]\nbcs = [S(0, x) ~ 0.9 + 0.1 * sin(2 * pi * x),\n    I(0, x) ~ 0.1 + 0.1 * cos(2 * pi * x),\n    Dx(S(t, 0)) ~ 0.0,\n    Dx(S(t, 1)) ~ 0.0,\n    Dx(I(t, 0)) ~ 0.0,\n    Dx(I(t, 1)) ~ 0.0]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 10.0),\n    x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [S(t, x), I(t, x)], [dS => 0.5, dI => 0.1, brn => 3, ϵ => 0.1])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.01\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization);","category":"page"},{"location":"tutorials/sispde/#Solving-time-dependent-SIS-epidemic-model","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Solving time dependent SIS epidemic model","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"# Solving SIS reaction diffusion model\nsol = solve(prob, Tsit5(), saveat=0.2);\n\n# Retriving the results\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\nS_solution = sol[S(t, x)]\nI_solution = sol[I(t, x)]\n\np = surface(discrete_x, discrete_t, S_solution)\ndisplay(p)","category":"page"},{"location":"tutorials/sispde/#Solving-steady-state-problem","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Solving steady state problem","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Change the elliptic problem to steady state problem of reaction diffusion equation.","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"See more solvers in Steady State Solvers · DifferentialEquations.jl","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"steadystateprob = SteadyStateProblem(prob)\nsteadystate = solve(steadystateprob, DynamicSS(Tsit5()))","category":"page"},{"location":"tutorials/sispde/#The-effect-of-human-mobility-on-endemic-size","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"The effect of human mobility on endemic size","text":"","category":"section"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Set the endemic size f(d_Sd_I) = int_0^1I(xd_Sd_I)","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"function episize!(dS, dI)\n    newprob = remake(prob, p=[dS, dI, 3, 0.1])\n    steadystateprob = SteadyStateProblem(newprob)\n    state = solve(steadystateprob, DynamicSS(Tsit5()))\n    y = sum(state[100:end]) / 99\n    return y\nend\nepisize!(exp(1.0),exp(0.5))","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"References:","category":"page"},{"location":"tutorials/sispde/","page":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","title":"Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model","text":"Allen L J S, Bolker B M, Lou Y, et al. Asymptotic profiles of the steady states for an SIS epidemic reaction-diffusion model[J]. Discrete & Continuous Dynamical Systems, 2008, 21(1): 1.","category":"page"},{"location":"boundary_conditions/#[Boundary-Conditions](@ref-bcs)","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"What follows is a set of allowable boundary conditions, please note that this is not exhaustive - try your condition and see if it works, the handling is quite general. If it doesn't please post an issue and we'll try to support it. At the moment boundary conditions have to be supplied at the edge of the domain, but there are plans to support conditions embedded in the domain.","category":"page"},{"location":"boundary_conditions/#Definitions","page":"Boundary Conditions","title":"Definitions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using ModelingToolkit, MethodOfLines, Domainsets\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\nx_min = y_min = 0.0\n\nx_max = y_max = 1.0","category":"page"},{"location":"boundary_conditions/#Dirichlet","page":"Boundary Conditions","title":"Dirichlet","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, 0, y) ~ 1.0","category":"page"},{"location":"boundary_conditions/#Time-dependant","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, 0., y) ~ x_min*y+ 0.5t","category":"page"},{"location":"boundary_conditions/#Julia-function","page":"Boundary Conditions","title":"Julia function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, y_max) ~ sin(x)","category":"page"},{"location":"boundary_conditions/#User-defined-function","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"alpha = 9\n\nf(t,x,y) = x*y - t\n\nfunction g(x,y) \n    z = sin(x*y)+cos(y)\n    # Note that symbolic conditionals require the use of IfElse.ifelse, or registration\n    return IfElse.ifelse(z > 0, x, 1.0)\nend\n\nu(t,x,y_min) ~ f(t,x,y_min) + alpha/g(x,y_min)","category":"page"},{"location":"boundary_conditions/#Registered-User-Defined-Function","page":"Boundary Conditions","title":"Registered User Defined Function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"alpha = 9\n\nf(t,x,y) = x*y - t\n\nfunction g(x,y) \n    z = sin(x*y)+cos(y)\n    # This function must be registered as it contains a symbolic conditional\n    if z > 0\n        return x\n    else\n        return 1.0\n    end\nend\n\n@register g(x, y)\n\nu(t,x,y_min) ~ f(t,x,y_min) + alpha/g(x,y_min)","category":"page"},{"location":"boundary_conditions/#Neumann/Robin","page":"Boundary Conditions","title":"Neumann/Robin","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x_min, y) ~ 2. * Dx(v(t, x_min, y))","category":"page"},{"location":"boundary_conditions/#Time-dependant-2","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ x_min*Dy(v(t,x_min,y)) + 0.5t","category":"page"},{"location":"boundary_conditions/#Higher-order","page":"Boundary Conditions","title":"Higher order","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, 1.0) ~ sin(x) + Dyy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Time-derivative","page":"Boundary Conditions","title":"Time derivative","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Dt(u(t, x_min, y)) ~ 0.2","category":"page"},{"location":"boundary_conditions/#User-defined-function-2","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"function f(u, v)\n    (u + Dyy(v) - Dy(u))/(1 + v)\nend\n\nDyy(u(t, x, y_min)) ~ f(u(t, x, y_min), v(t, x, y_min)) + 1","category":"page"},{"location":"boundary_conditions/#lhs","page":"Boundary Conditions","title":"0 lhs","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"0 ~ u(t, x, y_max) - Dy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Periodic","page":"Boundary Conditions","title":"Periodic","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ u(t, x_max, y)\n\nv(t, x, y_max) ~ u(t, x_max, y)","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Please note that if you want to use a periodic condition on a dimension with WENO schemes, please use a periodic condition on all variables in that dimension.","category":"page"},{"location":"boundary_conditions/#Interfaces","page":"Boundary Conditions","title":"Interfaces","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"You may want to connect regions with differing dynamics together, to do this follow the following example, splitting the variable that spans these domains:","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"    @parameters t x1 x2\n    @variables c1(..)\n    @variables c2(..)\n    Dt = Differential(t)\n\n    Dx1 = Differential(x1)\n    Dxx1 = Dx1^2\n\n    Dx2 = Differential(x2)\n    Dxx2 = Dx2^2\n\n    D1(c) = 1 + c / 10\n    D2(c) = 1 / 10 + c / 10\n\n    eqs = [Dt(c1(t, x1)) ~ Dx1(D1(c1(t, x1)) * Dx1(c1(t, x1))),\n        Dt(c2(t, x2)) ~ Dx2(D2(c2(t, x2)) * Dx2(c2(t, x2)))]\n\n    bcs = [c1(0, x1) ~ 1 + cospi(2 * x1),\n        c2(0, x2) ~ 1 + cospi(2 * x2),\n        Dx1(c1(t, 0)) ~ 0,\n        c1(t, 0.5) ~ c2(t, 0.5), # Relevant interface boundary condition\n        -D1(c1(t, 0.5)) * Dx1(c1(t, 0.5)) ~ -D2(c2(t, 0.5)) * Dx2(c2(t, 0.5)), # Higher order interface condition\n        Dx2(c2(t, 1)) ~ 0]\n\n    domains = [t ∈ Interval(0.0, 0.15),\n        x1 ∈ Interval(0.0, 0.5),\n        x2 ∈ Interval(0.5, 1.0)]\n\n    @named pdesys = PDESystem(eqs, bcs, domains,\n        [t, x1, x2], [c1(t, x1), c2(t, x2)])","category":"page"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Note that if you want to use a higher order interface condition, this may not work if you have no simple condition of the form c1(t, 0.5) ~ c2(t, 0.5).","category":"page"},{"location":"get_grid/#get_grid","page":"Grid and Solution Retrieval - Deprecated","title":"get_discrete","text":"","category":"section"},{"location":"get_grid/","page":"Grid and Solution Retrieval - Deprecated","title":"Grid and Solution Retrieval - Deprecated","text":"warn: Warn\nThis method is deprecated in favour of the newer solution interface, and has much worse performance. These methods will now only work with sol.original_sol.","category":"page"},{"location":"get_grid/","page":"Grid and Solution Retrieval - Deprecated","title":"Grid and Solution Retrieval - Deprecated","text":"MethodOfLines.jl exports a helper function get_discrete, which returns a Dict with the keys being the independent and dependent variables, and the values their corresponding discrete grid, and discretized variables used in the discretization. It is used as following:","category":"page"},{"location":"get_grid/","page":"Grid and Solution Retrieval - Deprecated","title":"Grid and Solution Retrieval - Deprecated","text":"grid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\n# Retrieve shaped solution\nu_sol = [map(d -> sol[d][i], grid[u(t, x)]) for i in 1:length(sol[t])]","category":"page"},{"location":"generated/bruss_ode_eqs/#brusssys","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"Here's the generated system of equations for the Brusselator, with dx = dy = 1/4","category":"page"},{"location":"generated/bruss_ode_eqs/#Equations-for-u","page":"Generated ODE system for the Brusselator Equation","title":"Equations for u","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"[Differential(t)(u[2, 2](t)) ~ 1.0 + 160.0u[3, 2](t) + 160.0u[5, 2](t) - 320.0u[2, 2](t) + 160.0u[2, 3](t) + 160.0u[2, 5](t) - 320.0u[2, 2](t) + (u[2, 2](t)^2)*v[2, 2](t) - 4.4u[2, 2](t), \nDifferential(t)(u[3, 2](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[4, 2](t) - 320.0u[3, 2](t) + 160.0u[3, 3](t) + 160.0u[3, 5](t) - 320.0u[3, 2](t) + (u[3, 2](t)^2)*v[3, 2](t) - 4.4u[3, 2](t), \nDifferential(t)(u[4, 2](t)) ~ 1.0 + 160.0u[4, 3](t) + 160.0u[4, 5](t) - 320.0u[4, 2](t) + 160.0u[3, 2](t) + 160.0u[5, 2](t) - 320.0u[4, 2](t) + (u[4, 2](t)^2)*v[4, 2](t) - 4.4u[4, 2](t), \nDifferential(t)(u[5, 2](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[4, 2](t) - 320.0u[5, 2](t) + 160.0u[5, 3](t) + 160.0u[5, 5](t) - 320.0u[5, 2](t) + (u[5, 2](t)^2)*v[5, 2](t) - 4.4u[5, 2](t), \nDifferential(t)(u[2, 3](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[2, 4](t) - 320.0u[2, 3](t) + 160.0u[3, 3](t) + 160.0u[5, 3](t) - 320.0u[2, 3](t) + (u[2, 3](t)^2)*v[2, 3](t) - 4.4u[2, 3](t), \nDifferential(t)(u[3, 3](t)) ~ 1.0 + 160.0u[2, 3](t) + 160.0u[4, 3](t) - 320.0u[3, 3](t) + 160.0u[3, 2](t) + 160.0u[3, 4](t) - 320.0u[3, 3](t) + (u[3, 3](t)^2)*v[3, 3](t) - 4.4u[3, 3](t), \nDifferential(t)(u[4, 3](t)) ~ 1.0 + 160.0u[3, 3](t) + 160.0u[5, 3](t) - 320.0u[4, 3](t) + 160.0u[4, 2](t) + 160.0u[4, 4](t) - 320.0u[4, 3](t) + (u[4, 3](t)^2)*v[4, 3](t) - 4.4u[4, 3](t), \nDifferential(t)(u[5, 3](t)) ~ 1.0 + 160.0u[2, 3](t) + 160.0u[4, 3](t) - 320.0u[5, 3](t) + 160.0u[5, 2](t) + 160.0u[5, 4](t) - 320.0u[5, 3](t) + (u[5, 3](t)^2)*v[5, 3](t) - 4.4u[5, 3](t), \nDifferential(t)(u[2, 4](t)) ~ 1.0 + 160.0u[3, 4](t) + 160.0u[5, 4](t) - 320.0u[2, 4](t) + 160.0u[2, 3](t) + 160.0u[2, 5](t) - 320.0u[2, 4](t) + (u[2, 4](t)^2)*v[2, 4](t) - 4.4u[2, 4](t), \nDifferential(t)(u[3, 4](t)) ~ 1.0 + 160.0u[2, 4](t) + 160.0u[4, 4](t) - 320.0u[3, 4](t) + 160.0u[3, 3](t) + 160.0u[3, 5](t) - 320.0u[3, 4](t) + (u[3, 4](t)^2)*v[3, 4](t) - 4.4u[3, 4](t), \nDifferential(t)(u[4, 4](t)) ~ 1.0 + 160.0u[4, 3](t) + 160.0u[4, 5](t) - 320.0u[4, 4](t) + 160.0u[3, 4](t) + 160.0u[5, 4](t) - 320.0u[4, 4](t) + (u[4, 4](t)^2)*v[4, 4](t) - 4.4u[4, 4](t), \nDifferential(t)(u[5, 4](t)) ~ 1.0 + 160.0u[2, 4](t) + 160.0u[4, 4](t) - 320.0u[5, 4](t) + 160.0u[5, 3](t) + 160.0u[5, 5](t) - 320.0u[5, 4](t) + (u[5, 4](t)^2)*v[5, 4](t) - 4.4u[5, 4](t), \nDifferential(t)(u[2, 5](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[2, 4](t) - 320.0u[2, 5](t) + 160.0u[3, 5](t) + 160.0u[5, 5](t) - 320.0u[2, 5](t) + (u[2, 5](t)^2)*v[2, 5](t) - 4.4u[2, 5](t), \nDifferential(t)(u[3, 5](t)) ~ 1.0 + 160.0u[2, 5](t) + 160.0u[4, 5](t) - 320.0u[3, 5](t) + 160.0u[3, 2](t) + 160.0u[3, 4](t) - 320.0u[3, 5](t) + (u[3, 5](t)^2)*v[3, 5](t) - 4.4u[3, 5](t), \nDifferential(t)(u[4, 5](t)) ~ 1.0 + 160.0u[3, 5](t) + 160.0u[5, 5](t) - 320.0u[4, 5](t) + 160.0u[4, 2](t) + 160.0u[4, 4](t) - 320.0u[4, 5](t) + (u[4, 5](t)^2)*v[4, 5](t) - 4.4u[4, 5](t), \nDifferential(t)(u[5, 5](t)) ~ 1.0 + 160.0u[2, 5](t) + 160.0u[4, 5](t) - 320.0u[5, 5](t) + 160.0u[5, 2](t) + 160.0u[5, 4](t) - 320.0u[5, 5](t) + (u[5, 5](t)^2)*v[5, 5](t) - 4.4u[5, 5](t)] ","category":"page"},{"location":"generated/bruss_ode_eqs/#Equations-for-v","page":"Generated ODE system for the Brusselator Equation","title":"Equations for v","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"[Differential(t)(v[2, 2](t)) ~ 160.0v[2, 3](t) + 160.0v[2, 5](t) - 320.0v[2, 2](t) + 160.0v[3, 2](t) + 160.0v[5, 2](t) - 320.0v[2, 2](t) + 3.4u[2, 2](t) - (u[2, 2](t)^2)*v[2, 2](t), \nDifferential(t)(v[3, 2](t)) ~ 160.0v[2, 2](t) + 160.0v[4, 2](t) - 320.0v[3, 2](t) + 160.0v[3, 3](t) + 160.0v[3, 5](t) - 320.0v[3, 2](t) + 3.4u[3, 2](t) - (u[3, 2](t)^2)*v[3, 2](t), \nDifferential(t)(v[4, 2](t)) ~ 160.0v[3, 2](t) + 160.0v[5, 2](t) - 320.0v[4, 2](t) + 160.0v[4, 3](t) + 160.0v[4, 5](t) - 320.0v[4, 2](t) + 3.4u[4, 2](t) - (u[4, 2](t)^2)*v[4, 2](t), \nDifferential(t)(v[5, 2](t)) ~ 160.0v[5, 3](t) + 160.0v[5, 5](t) - 320.0v[5, 2](t) + 160.0v[2, 2](t) + 160.0v[4, 2](t) - 320.0v[5, 2](t) + 3.4u[5, 2](t) - (u[5, 2](t)^2)*v[5, 2](t), \nDifferential(t)(v[2, 3](t)) ~ 160.0v[2, 2](t) + 160.0v[2, 4](t) - 320.0v[2, 3](t) + 160.0v[3, 3](t) + 160.0v[5, 3](t) - 320.0v[2, 3](t) + 3.4u[2, 3](t) - (u[2, 3](t)^2)*v[2, 3](t), \nDifferential(t)(v[3, 3](t)) ~ 160.0v[3, 2](t) + 160.0v[3, 4](t) - 320.0v[3, 3](t) + 160.0v[2, 3](t) + 160.0v[4, 3](t) - 320.0v[3, 3](t) + 3.4u[3, 3](t) - (u[3, 3](t)^2)*v[3, 3](t), \nDifferential(t)(v[4, 3](t)) ~ 160.0v[3, 3](t) + 160.0v[5, 3](t) - 320.0v[4, 3](t) + 160.0v[4, 2](t) + 160.0v[4, 4](t) - 320.0v[4, 3](t) + 3.4u[4, 3](t) - (u[4, 3](t)^2)*v[4, 3](t), \nDifferential(t)(v[5, 3](t)) ~ 160.0v[2, 3](t) + 160.0v[4, 3](t) - 320.0v[5, 3](t) + 160.0v[5, 2](t) + 160.0v[5, 4](t) - 320.0v[5, 3](t) + 3.4u[5, 3](t) - (u[5, 3](t)^2)*v[5, 3](t), \nDifferential(t)(v[2, 4](t)) ~ 160.0v[2, 3](t) + 160.0v[2, 5](t) - 320.0v[2, 4](t) + 160.0v[3, 4](t) + 160.0v[5, 4](t) - 320.0v[2, 4](t) + 3.4u[2, 4](t) - (u[2, 4](t)^2)*v[2, 4](t), \nDifferential(t)(v[3, 4](t)) ~ 160.0v[2, 4](t) + 160.0v[4, 4](t) - 320.0v[3, 4](t) + 160.0v[3, 3](t) + 160.0v[3, 5](t) - 320.0v[3, 4](t) + 3.4u[3, 4](t) - (u[3, 4](t)^2)*v[3, 4](t), \nDifferential(t)(v[4, 4](t)) ~ 160.0v[3, 4](t) + 160.0v[5, 4](t) - 320.0v[4, 4](t) + 160.0v[4, 3](t) + 160.0v[4, 5](t) - 320.0v[4, 4](t) + 3.4u[4, 4](t) - (u[4, 4](t)^2)*v[4, 4](t), \nDifferential(t)(v[5, 4](t)) ~ 160.0v[2, 4](t) + 160.0v[4, 4](t) - 320.0v[5, 4](t) + 160.0v[5, 3](t) + 160.0v[5, 5](t) - 320.0v[5, 4](t) + 3.4u[5, 4](t) - (u[5, 4](t)^2)*v[5, 4](t), \nDifferential(t)(v[2, 5](t)) ~ 160.0v[2, 2](t) + 160.0v[2, 4](t) - 320.0v[2, 5](t) + 160.0v[3, 5](t) + 160.0v[5, 5](t) - 320.0v[2, 5](t) + 3.4u[2, 5](t) - (u[2, 5](t)^2)*v[2, 5](t), \nDifferential(t)(v[3, 5](t)) ~ 160.0v[2, 5](t) + 160.0v[4, 5](t) - 320.0v[3, 5](t) + 160.0v[3, 2](t) + 160.0v[3, 4](t) - 320.0v[3, 5](t) + 3.4u[3, 5](t) - (u[3, 5](t)^2)*v[3, 5](t), \nDifferential(t)(v[4, 5](t)) ~ 160.0v[4, 2](t) + 160.0v[4, 4](t) - 320.0v[4, 5](t) + 160.0v[3, 5](t) + 160.0v[5, 5](t) - 320.0v[4, 5](t) + 3.4u[4, 5](t) - (u[4, 5](t)^2)*v[4, 5](t), \nDifferential(t)(v[5, 5](t)) ~ 160.0v[2, 5](t) + 160.0v[4, 5](t) - 320.0v[5, 5](t) + 160.0v[5, 2](t) + 160.0v[5, 4](t) - 320.0v[5, 5](t) + 3.4u[5, 5](t) - (u[5, 5](t)^2)*v[5, 5](t)]","category":"page"},{"location":"generated/bruss_ode_eqs/#Boundary-condition-Equations","page":"Generated ODE system for the Brusselator Equation","title":"Boundary condition Equations","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"u[2, 1](t) ~ u[2, 5](t), \nu[3, 1](t) ~ u[3, 5](t), \nu[4, 1](t) ~ u[4, 5](t), \nu[5, 1](t) ~ u[5, 5](t), \nu[1, 2](t) ~ u[5, 2](t), \nu[1, 3](t) ~ u[5, 3](t), \nu[1, 4](t) ~ u[5, 4](t), \nu[1, 5](t) ~ u[5, 5](t), \nu[1, 1](t) ~ 0, # Invalid corner point set to 0\nv[2, 1](t) ~ v[2, 5](t), \nv[3, 1](t) ~ v[3, 5](t), \nv[4, 1](t) ~ v[4, 5](t), \nv[5, 1](t) ~ v[5, 5](t), \nv[1, 2](t) ~ v[5, 2](t), \nv[1, 3](t) ~ v[5, 3](t), \nv[1, 4](t) ~ v[5, 4](t), \nv[1, 5](t) ~ v[5, 5](t), \nv[1, 1](t) ~ 0] # Invalid corner point set to 0","category":"page"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"On the call to ODEProblem, this code is generated.","category":"page"},{"location":"generated/bruss_code/#brusscode","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"","category":"section"},{"location":"generated/bruss_code/","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"Here's the generated julia code for the Brusselator, with dx = dy = 1/4","category":"page"},{"location":"generated/bruss_code/","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"begin\n    var\"##f#260\" = (ModelingToolkit.ODEFunctionClosure)(function (ˍ₋arg1, ˍ₋arg2, t)\n                begin\n                    var\"u[2, 2](t)\" = @inbounds(ˍ₋arg1[1])\n                    var\"u[3, 2](t)\" = @inbounds(ˍ₋arg1[2])\n                    var\"u[4, 2](t)\" = @inbounds(ˍ₋arg1[3])\n                    var\"u[5, 2](t)\" = @inbounds(ˍ₋arg1[4])\n                    var\"u[2, 3](t)\" = @inbounds(ˍ₋arg1[5])\n                    var\"u[3, 3](t)\" = @inbounds(ˍ₋arg1[6])\n                    var\"u[4, 3](t)\" = @inbounds(ˍ₋arg1[7])\n                    var\"u[5, 3](t)\" = @inbounds(ˍ₋arg1[8])\n                    var\"u[2, 4](t)\" = @inbounds(ˍ₋arg1[9])\n                    var\"u[3, 4](t)\" = @inbounds(ˍ₋arg1[10])\n                    var\"u[4, 4](t)\" = @inbounds(ˍ₋arg1[11])\n                    var\"u[5, 4](t)\" = @inbounds(ˍ₋arg1[12])\n                    var\"u[2, 5](t)\" = @inbounds(ˍ₋arg1[13])\n                    var\"u[3, 5](t)\" = @inbounds(ˍ₋arg1[14])\n                    var\"u[4, 5](t)\" = @inbounds(ˍ₋arg1[15])\n                    var\"u[5, 5](t)\" = @inbounds(ˍ₋arg1[16])\n                    var\"v[2, 2](t)\" = @inbounds(ˍ₋arg1[17])\n                    var\"v[3, 2](t)\" = @inbounds(ˍ₋arg1[18])\n                    var\"v[4, 2](t)\" = @inbounds(ˍ₋arg1[19])\n                    var\"v[5, 2](t)\" = @inbounds(ˍ₋arg1[20])\n                    var\"v[2, 3](t)\" = @inbounds(ˍ₋arg1[21])\n                    var\"v[3, 3](t)\" = @inbounds(ˍ₋arg1[22])\n                    var\"v[4, 3](t)\" = @inbounds(ˍ₋arg1[23])\n                    var\"v[5, 3](t)\" = @inbounds(ˍ₋arg1[24])\n                    var\"v[2, 4](t)\" = @inbounds(ˍ₋arg1[25])\n                    var\"v[3, 4](t)\" = @inbounds(ˍ₋arg1[26])\n                    var\"v[4, 4](t)\" = @inbounds(ˍ₋arg1[27])\n                    var\"v[5, 4](t)\" = @inbounds(ˍ₋arg1[28])\n                    var\"v[2, 5](t)\" = @inbounds(ˍ₋arg1[29])\n                    var\"v[3, 5](t)\" = @inbounds(ˍ₋arg1[30])\n                    var\"v[4, 5](t)\" = @inbounds(ˍ₋arg1[31])\n                    var\"v[5, 5](t)\" = @inbounds(ˍ₋arg1[32])\n                    begin\n                        (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(32,)}(), (+)((+)((+)((+)((+)((+)(1.0, (*)(-644.4, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)((^)(var\"u[2, 2](t)\", 2), var\"v[2, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)((^)(var\"u[3, 2](t)\", 2), var\"v[3, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[4, 2](t)\")), (*)((^)(var\"u[4, 2](t)\", 2), var\"v[4, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 2](t)\")), (*)((^)(var\"u[5, 2](t)\", 2), var\"v[5, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[2, 3](t)\", 2), var\"v[2, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[3, 3](t)\")), (*)((^)(var\"u[3, 3](t)\", 2), var\"v[3, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(-644.4, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[4, 3](t)\", 2), var\"v[4, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 3](t)\", 2), var\"v[5, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[2, 4](t)\")), (*)((^)(var\"u[2, 4](t)\", 2), var\"v[2, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(-644.4, var\"u[3, 4](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)((^)(var\"u[3, 4](t)\", 2), var\"v[3, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[4, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[4, 4](t)\", 2), var\"v[4, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 4](t)\", 2), var\"v[5, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(-644.4, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[2, 5](t)\", 2), var\"v[2, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(-644.4, var\"u[3, 5](t)\")), (*)((^)(var\"u[3, 5](t)\", 2), var\"v[3, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(-644.4, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[4, 5](t)\", 2), var\"v[4, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[5, 5](t)\")), (*)((^)(var\"u[5, 5](t)\", 2), var\"v[5, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 2](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(-640.0, var\"v[2, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 2](t)\", 2)), var\"v[2, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 2](t)\", 2)), var\"v[3, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 2](t)\"), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 5](t)\"))[Imgur](https://i.imgur.com/3kQNMI3.gifv), (*)(160.0, var\"v[5, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 2](t)\", 2)), var\"v[4, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 2](t)\", 2)), var\"v[5, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 3](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 3](t)\", 2)), var\"v[2, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[3, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 3](t)\", 2)), var\"v[3, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 3](t)\"), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 3](t)\", 2)), var\"v[4, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 3](t)\", 2)), var\"v[5, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 4](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[2, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 4](t)\", 2)), var\"v[2, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(-640.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 4](t)\", 2)), var\"v[3, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 4](t)\"), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 4](t)\", 2)), var\"v[4, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(-640.0, var\"v[5, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 4](t)\", 2)), var\"v[5, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 5](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(-640.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 5](t)\", 2)), var\"v[2, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(-640.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 5](t)\", 2)), var\"v[3, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 5](t)\"), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)(-640.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 5](t)\", 2)), var\"v[4, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 5](t)\", 2)), var\"v[5, 5](t)\")))\n                    end\n                end\n            end, function (ˍ₋out, ˍ₋arg1, ˍ₋arg2, t)\n                begin\n                    var\"u[2, 2](t)\" = @inbounds(ˍ₋arg1[1])\n                    var\"u[3, 2](t)\" = @inbounds(ˍ₋arg1[2])\n                    var\"u[4, 2](t)\" = @inbounds(ˍ₋arg1[3])\n                    var\"u[5, 2](t)\" = @inbounds(ˍ₋arg1[4])\n                    var\"u[2, 3](t)\" = @inbounds(ˍ₋arg1[5])\n                    var\"u[3, 3](t)\" = @inbounds(ˍ₋arg1[6])\n                    var\"u[4, 3](t)\" = @inbounds(ˍ₋arg1[7])\n                    var\"u[5, 3](t)\" = @inbounds(ˍ₋arg1[8])\n                    var\"u[2, 4](t)\" = @inbounds(ˍ₋arg1[9])\n                    var\"u[3, 4](t)\" = @inbounds(ˍ₋arg1[10])\n                    var\"u[4, 4](t)\" = @inbounds(ˍ₋arg1[11])\n                    var\"u[5, 4](t)\" = @inbounds(ˍ₋arg1[12])\n                    var\"u[2, 5](t)\" = @inbounds(ˍ₋arg1[13])\n                    var\"u[3, 5](t)\" = @inbounds(ˍ₋arg1[14])\n                    var\"u[4, 5](t)\" = @inbounds(ˍ₋arg1[15])\n                    var\"u[5, 5](t)\" = @inbounds(ˍ₋arg1[16])\n                    var\"v[2, 2](t)\" = @inbounds(ˍ₋arg1[17])\n                    var\"v[3, 2](t)\" = @inbounds(ˍ₋arg1[18])\n                    var\"v[4, 2](t)\" = @inbounds(ˍ₋arg1[19])\n                    var\"v[5, 2](t)\" = @inbounds(ˍ₋arg1[20])\n                    var\"v[2, 3](t)\" = @inbounds(ˍ₋arg1[21])\n                    var\"v[3, 3](t)\" = @inbounds(ˍ₋arg1[22])\n                    var\"v[4, 3](t)\" = @inbounds(ˍ₋arg1[23])\n                    var\"v[5, 3](t)\" = @inbounds(ˍ₋arg1[24])\n                    var\"v[2, 4](t)\" = @inbounds(ˍ₋arg1[25])\n                    var\"v[3, 4](t)\" = @inbounds(ˍ₋arg1[26])\n                    var\"v[4, 4](t)\" = @inbounds(ˍ₋arg1[27])\n                    var\"v[5, 4](t)\" = @inbounds(ˍ₋arg1[28])\n                    var\"v[2, 5](t)\" = @inbounds(ˍ₋arg1[29])\n                    var\"v[3, 5](t)\" = @inbounds(ˍ₋arg1[30])\n                    var\"v[4, 5](t)\" = @inbounds(ˍ₋arg1[31])\n                    var\"v[5, 5](t)\" = @inbounds(ˍ₋arg1[32])\n                    begin\n                        @inbounds begin\n                                ˍ₋out[1] = (+)((+)((+)((+)((+)((+)(1.0, (*)(-644.4, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)((^)(var\"u[2, 2](t)\", 2), var\"v[2, 2](t)\"))\n                                ˍ₋out[2] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)((^)(var\"u[3, 2](t)\", 2), var\"v[3, 2](t)\"))\n                                ˍ₋out[3] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[4, 2](t)\")), (*)((^)(var\"u[4, 2](t)\", 2), var\"v[4, 2](t)\"))\n                                ˍ₋out[4] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 2](t)\")), (*)((^)(var\"u[5, 2](t)\", 2), var\"v[5, 2](t)\"))\n                                ˍ₋out[5] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[2, 3](t)\", 2), var\"v[2, 3](t)\"))\n                                ˍ₋out[6] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[3, 3](t)\")), (*)((^)(var\"u[3, 3](t)\", 2), var\"v[3, 3](t)\"))\n                                ˍ₋out[7] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(-644.4, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[4, 3](t)\", 2), var\"v[4, 3](t)\"))\n                                ˍ₋out[8] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 3](t)\", 2), var\"v[5, 3](t)\"))\n                                ˍ₋out[9] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[2, 4](t)\")), (*)((^)(var\"u[2, 4](t)\", 2), var\"v[2, 4](t)\"))\n                                ˍ₋out[10] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(-644.4, var\"u[3, 4](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)((^)(var\"u[3, 4](t)\", 2), var\"v[3, 4](t)\"))\n                                ˍ₋out[11] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[4, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[4, 4](t)\", 2), var\"v[4, 4](t)\"))\n                                ˍ₋out[12] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 4](t)\", 2), var\"v[5, 4](t)\"))\n                                ˍ₋out[13] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(-644.4, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[2, 5](t)\", 2), var\"v[2, 5](t)\"))\n                                ˍ₋out[14] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(-644.4, var\"u[3, 5](t)\")), (*)((^)(var\"u[3, 5](t)\", 2), var\"v[3, 5](t)\"))\n                                ˍ₋out[15] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(-644.4, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[4, 5](t)\", 2), var\"v[4, 5](t)\"))\n                                ˍ₋out[16] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[5, 5](t)\")), (*)((^)(var\"u[5, 5](t)\", 2), var\"v[5, 5](t)\"))\n                                ˍ₋out[17] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 2](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(-640.0, var\"v[2, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 2](t)\", 2)), var\"v[2, 2](t)\"))\n                                ˍ₋out[18] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 2](t)\", 2)), var\"v[3, 2](t)\"))\n                                ˍ₋out[19] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 2](t)\"), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 2](t)\", 2)), var\"v[4, 2](t)\"))\n                                ˍ₋out[20] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 2](t)\", 2)), var\"v[5, 2](t)\"))\n                                ˍ₋out[21] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 3](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 3](t)\", 2)), var\"v[2, 3](t)\"))[Imgur](https://i.imgur.com/3kQNMI3.gifv)\n                                ˍ₋out[22] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[3, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 3](t)\", 2)), var\"v[3, 3](t)\"))\n                                ˍ₋out[23] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 3](t)\"), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 3](t)\", 2)), var\"v[4, 3](t)\"))\n                                ˍ₋out[24] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 3](t)\", 2)), var\"v[5, 3](t)\"))\n                                ˍ₋out[25] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 4](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[2, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 4](t)\", 2)), var\"v[2, 4](t)\"))\n                                ˍ₋out[26] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(-640.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 4](t)\", 2)), var\"v[3, 4](t)\"))\n                                ˍ₋out[27] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 4](t)\"), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 4](t)\", 2)), var\"v[4, 4](t)\"))\n                                ˍ₋out[28] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(-640.0, var\"v[5, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 4](t)\", 2)), var\"v[5, 4](t)\"))\n                                ˍ₋out[29] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 5](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(-640.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 5](t)\", 2)), var\"v[2, 5](t)\"))\n                                ˍ₋out[30] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(-640.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 5](t)\", 2)), var\"v[3, 5](t)\"))\n                                ˍ₋out[31] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 5](t)\"), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)(-640.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 5](t)\", 2)), var\"v[4, 5](t)\"))\n                                ˍ₋out[32] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 5](t)\", 2)), var\"v[5, 5](t)\"))\n                                nothing\n                            end\n                    end\n                end\n            end)\n    var\"##tgrad#261\" = nothing\n    var\"##jac#262\" = nothing\n    M = UniformScaling{Bool}(true)\n    ODEFunction{true}(var\"##f#260\", jac = var\"##jac#262\", tgrad = var\"##tgrad#261\", mass_matrix = M, jac_prototype = nothing, syms = [Symbol(\"u[2, 2](t)\"), Symbol(\"u[3, 2](t)\"), Symbol(\"u[4, 2](t)\"), Symbol(\"u[5, 2](t)\"), Symbol(\"u[2, 3](t)\"), Symbol(\"u[3, 3](t)\"), Symbol(\"u[4, 3](t)\"), Symbol(\"u[5, 3](t)\"), Symbol(\"u[2, 4](t)\"), Symbol(\"u[3, 4](t)\"), Symbol(\"u[4, 4](t)\"), Symbol(\"u[5, 4](t)\"), Symbol(\"u[2, 5](t)\"), Symbol(\"u[3, 5](t)\"), Symbol(\"u[4, 5](t)\"), Symbol(\"u[5, 5](t)\"), Symbol(\"v[2, 2](t)\"), Symbol(\"v[3, 2](t)\"), Symbol(\"v[4, 2](t)\"), Symbol(\"v[5, 2](t)\"), Symbol(\"v[2, 3](t)\"), Symbol(\"v[3, 3](t)\"), Symbol(\"v[4, 3](t)\"), Symbol(\"v[5, 3](t)\"), Symbol(\"v[2, 4](t)\"), Symbol(\"v[3, 4](t)\"), Symbol(\"v[4, 4](t)\"), Symbol(\"v[5, 4](t)\"), Symbol(\"v[2, 5](t)\"), Symbol(\"v[3, 5](t)\"), Symbol(\"v[4, 5](t)\"), Symbol(\"v[5, 5](t)\")], indepsym = :t)\nend","category":"page"},{"location":"devnotes/#Notes-for-developers","page":"Notes for Developers: Implement a Scheme","title":"Notes for developers","text":"","category":"section"},{"location":"devnotes/#Getting-started","page":"Notes for Developers: Implement a Scheme","title":"Getting started","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"First, fork the repo and clone it locally.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Then, type in the REPL","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"julia>] dev /path/to/your/repo\njulia>] activate MethodOfLines","category":"page"},{"location":"devnotes/#Overview","page":"Notes for Developers: Implement a Scheme","title":"Overview","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"MethodOfLines.jl makes heavy use of Symbolics.jl and SymbolicUtils.jl, especially the replacement rules from the latter.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Take a look at src/discretization/MOL_discretization.jl to get a high level overview of how the discretization works. A more consise description can be found here. Feel free to post an issue if you would like help understanding anything, or want to know developer opinions on the best way to go about implementing something.","category":"page"},{"location":"devnotes/#Adding-new-finite-difference-schemes","page":"Notes for Developers: Implement a Scheme","title":"Adding new finite difference schemes","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"If you know of a finite difference scheme which is better than what is currently implemented, please first post an issue with a link to a paper.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"A replacement rule is generated for each term which has a more specific higher stability/accuracy finite difference scheme than the general central difference, which represents a base case.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Take a look at src/discretization/generate_finite_difference_rules.jl to see where the replacement rules are generated. Implemented schemes can be found in /src/discretization/schemes. Have a look at some of the already implemented examples there; read about the @rule macro from SymbolicUtils.jl, if you haven't already. Note that the order that the rules are applied is important; there may be schemes that are applied first that are special cases of more general rules, for example the sphrical laplacian is a special case of the nonlinear laplacian.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"First terms are split, isolating particular cases. Then, rules are generated and applied.  ","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Identify a rule which will match your case, then write a function that will handle how to apply that scheme for each index in the interior, for each combination of independant and dependant variables. ","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"This should be a function of the current index II::CartesianIndex, an independent variable x which represents the direction of the derivative, and a dependent variable u, which is the variable of which the derivative will be taken. The discrete representation of u is found in s.discvars[u], which is an array with the same number of spatial dimensions as u, each index a symbol representing the discretized u at that index. Using this, and cartesian index offsets from II, create a finite difference/volume symbolic expression for the approximation of the derivative form you are trying to discretize. This should be returned.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"For example, the following is a simple rule and function that would discretize derivatives of each dependent variable uin each dependent variable x with the second order central difference approximation:","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"#TODO: Add handling for cases where II is close to the boundaries\n#TODO: Handle periodic boundary conditions\n#TODO: Handle nonuniformly discretized `x`\nfunction second_order_central_difference(II::CartesianIndex, s::DiscreteSpace, u, x)\n    # Get which place `x` appears in `u`'s arguments\n    j = x2i(s, u, x)\n\n    # Get a CartesianIndex of unit length that points in the direction of `x` e.g. CartesianIndex((1, 0, 0))\n    I1 = unitindex(ndims(u, s), j) \n\n    discu = s.discvars[u]\n    expr = (discu[II + I1] - discu[II - I1])/s.dx[x]\n\n    return expr\nend\n\n# Note that indexmap is used along with the function `Idx` to create an equivalent index for the discrete form of `u`,\n# which may have a different number of dimensions to `II`\nfunction generate_central_difference_rules(II::CartesianIndex, s::DiscreteSpace, terms::Vector{<:Term}, indexmap::Dict)\n    rules = [[@rule Differential(x)(u) => second_order_central_difference(Idx(II, s, u, indexmap), s, u, x) for x in params(u, s)] for u in depvars]\n\n    rules = reduce(vcat, rules)\n\n    # Parse the rules in to pairs that can be used with `substitute`, this can be copy pasted.\n    rule_pairs = []\n    for t in terms\n        for r in rules\n            if r(t) !== nothing\n                push!(rule_pairs, t => r(t))\n            end\n        end\n    end\n    return rule_pairs\nend","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Initially, don't worry if your scheme is only implemented for specific approximation orders, it is sufficient just to warn when the requested approximation order does not match that supplied by the scheme. We can work in future pull requests to generalize the scheme to higher approximation orders, where possible.","category":"page"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"Finally, include your rules in the vector of rules to be used to replace terms in the PDE at this index, found here:","category":"page"},{"location":"devnotes/#Inspecting-generated-code","page":"Notes for Developers: Implement a Scheme","title":"Inspecting generated code","text":"","category":"section"},{"location":"devnotes/","page":"Notes for Developers: Implement a Scheme","title":"Notes for Developers: Implement a Scheme","text":"To get the generated code for your system, use code = ODEFunctionExpr(prob), or MethodOfLines.generate_code(pdesys, discretization, \"my_generated_code_filename.jl\"), which will create a file called my_generated_code_filename.jl in pwd(). This can be useful to find errors in the discretization, but note that it is not recommended to use this code directly, calling solve(prob, AppropriateSolver()) will handle this for you.","category":"page"},{"location":"tutorials/brusselator/#brusselator","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/brusselator/#Using-the-Brusselator-PDE-as-an-example","page":"Tutorial","title":"Using the Brusselator PDE as an example","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"The Brusselator PDE is defined as follows:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nfracpartial upartial t = 1 + u^2v - 44u + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2) + f(x y t)\nfracpartial vpartial t = 34u - u^2v + alpha(fracpartial^2 vpartial x^2 + fracpartial^2 vpartial y^2)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"where","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"f(x y t) = begincases\n5  quad textif  (x-03)^2+(y-06)^2  01^2 text and  t  11 \n0  quad textelse\nendcases","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"and the initial conditions are","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x y 0) = 22cdot (y(1-y))^32 \nv(x y 0) = 27cdot (x(1-x))^32\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"with the periodic boundary condition","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x+1yt) = u(xyt) \nu(xy+1t) = u(xyt)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"on a timespan of t in 0115.","category":"page"},{"location":"tutorials/brusselator/#Solving-with-MethodOfLines","page":"Tutorial","title":"Solving with MethodOfLines","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"With ModelingToolkit.jl, we first symbolicaly define the system, see also the docs for PDESystem:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\n∇²(u) = Dxx(u) + Dyy(u)\n\nbrusselator_f(x, y, t) = (((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.\n\nx_min = y_min = t_min = 0.0\nx_max = y_max = 1.0\nt_max = 11.5\n\nα = 10.\n\nu0(x,y,t) = 22(y*(1-y))^(3/2)\nv0(x,y,t) = 27(x*(1-x))^(3/2)\n\neq = [Dt(u(x,y,t)) ~ 1. + v(x,y,t)*u(x,y,t)^2 - 4.4*u(x,y,t) + α*∇²(u(x,y,t)) + brusselator_f(x, y, t),\n       Dt(v(x,y,t)) ~ 3.4*u(x,y,t) - v(x,y,t)*u(x,y,t)^2 + α*∇²(v(x,y,t))]\n\ndomains = [x ∈ Interval(x_min, x_max),\n              y ∈ Interval(y_min, y_max),\n              t ∈ Interval(t_min, t_max)]\n\n# Periodic BCs\nbcs = [u(x,y,0) ~ u0(x,y,0),\n       u(0,y,t) ~ u(1,y,t),\n       u(x,0,t) ~ u(x,1,t),\n\n       v(x,y,0) ~ v0(x,y,0),\n       v(0,y,t) ~ v(1,y,t),\n       v(x,0,t) ~ v(x,1,t)] \n\n@named pdesys = PDESystem(eq,bcs,domains,[x,y,t],[u(x,y,t),v(x,y,t)])","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For a list of limitations constraining which systems will work, see here","category":"page"},{"location":"tutorials/brusselator/#Method-of-lines-discretization","page":"Tutorial","title":"Method of lines discretization","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Then, we create the discretization, leaving the time dimension undiscretized by supplying t as an argument. Optionally, all dimensions can be discretized in this step, just remove the argument t and supply t=>dt in the dxs. See here for more information on the MOLFiniteDifference constructor arguments and options.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"N = 32\n\ndx = (x_max-x_min)/N\ndy = (y_max-y_min)/N\n\norder = 2\n\ndiscretization = MOLFiniteDifference([x=>dx, y=>dy], t, approx_order=order, grid_align=center_align)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Next, we discretize the system, converting the PDESystem in to an ODEProblem or NonlinearProblem.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"# Convert the PDE problem into an ODE problem\nprintln(\"Discretization:\")\n@time prob = discretize(pdesys,discretization)","category":"page"},{"location":"tutorials/brusselator/#Solving-the-problem","page":"Tutorial","title":"Solving the problem","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Now your problem can be solved with an appropriate ODE solver, or Nonlinear solver if you have not supplied a time dimension in the MOLFiniteDifference constructor. Include these solvers with using OrdinaryDiffEq or using NonlinearSolve, then call sol = solve(prob, AppropriateSolver()) or sol = NonlinearSolve.solve(prob, AppropriateSolver()). For more information on the available solvers, see the docs for DifferentialEquations.jl, NonlinearSolve.jl and SteadyStateDiffEq.jl. Tsit5() is a good first choice of solver for many problems.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"println(\"Solve:\")\n@time sol = solve(prob, TRBDF2(), saveat=0.1)","category":"page"},{"location":"tutorials/brusselator/#Extracting-results","page":"Tutorial","title":"Extracting results","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"To retrieve your solution, for example for u, use sol[u(x, y, t)]. To get the independent variable axes, use for example sol[t]. For more information on the solution interface, see this page","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"discrete_x = sol[x]\ndiscrete_y = sol[y]\ndiscrete_t = sol[t]\n\nsolu = sol[u(x, y, t)]\nsolv = sol[v(x, y, t)]","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"The result after plotting an animation:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For u:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"using Plots\nanim = @animate for k in 1:length(discrete_t)\n    heatmap(solu[k, 2:end, 2:end], title=\"$(discrete_t[k])\") # 2:end since end = 1, periodic condition\nend\ngif(anim, \"plots/Brusselator2Dsol_u.gif\", fps = 8)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"(Image: Brusselator2Dsol_u)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For v:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"anim = @animate for k in 1:length(discrete_t)\n    heatmap(solv[k, 2:end, 2:end], title=\"$(discrete_t[k])\")\nend\ngif(anim, \"plots/Brusselator2Dsol_v.gif\", fps = 8)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"(Image: Brusselator2Dsol_v)","category":"page"},{"location":"MOLFiniteDifference/#molfd","page":"MOLFiniteDifference","title":"Discretization","text":"","category":"section"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"struct MOLFiniteDifference{G} <: DiffEqBase.AbstractDiscretization\n    dxs\n    time\n    approx_order::Int\n    advection_scheme\n    grid_align::G\n    should_transform::Bool\n    use_ODAE::Bool\n    kwargs\nend","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"eq = [your system of equations, see examples for possibilities]\nbcs = [your boundary conditions, see examples for possibilities]\n\ndomain = [your domain, a vector of Intervals i.e. x ∈ Interval(x_min, x_max)]\n\n@named pdesys = PDESystem(eq, bcs, domains, [t, x, y], [u(t, x, y)])\n\ndiscretization = MOLFiniteDifference(dxs, \n                                      <your choice of continuous variable, usually time>; \n                                      advection_scheme = <UpwindScheme() or WENOScheme()>, \n                                      approx_order = <Order of derivative approximation, starting from 2> \n                                      grid_align = <your grid type choice>,\n                                      should_transform = <Whether to automatically transform the PDESystem (see below)>\n                                      use_ODAE = <Whether to use ODAEProblem>)\nprob = discretize(pdesys, discretization)","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Where dxs is a vector of pairs of parameters to the grid step in this dimension, i.e. [x=>0.2, y=>0.1]. If the value given for a dimension is a subtype of Integer, the domain for that variable will be discretized in to that integer number of equally spaced points.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"For a non uniform rectilinear grid, replace any or all of the step sizes with the grid you'd like to use with that variable, must be an AbstractVector but not a StepRangeLen.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Note that the second argument to MOLFiniteDifference is optional, all parameters can be discretized if all required boundary conditions are specified.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Currently implemented options for advection_scheme are UpwindScheme() and WENOScheme(), defaults to upwind. See advection schemes for more information.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Currently supported grid_align: center_align and edge_align. Edge align will give better accuracy with Neumann boundary conditions. Defaults tp center_align.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"center_align: naive grid, starting from lower boundary, ending on upper boundary with step of dx","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"edge_align: offset grid, set halfway between the points that would be generated with center_align, with extra points at either end that are above and below the supremum and infimum by dx/2. This improves accuracy for Neumann BCs.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"should_transform: Whether to automatically transform the system to make it compatible with MethodOfLines where possible, defaults to true. If your system has no mixed derivatives, all derivatives are purely of a dependent variable i.e. Dx(u_aux(t,x)) not Dx(v(t,x)*u(t,x)), excepting nonlinear and spherical laplacians for which this holds for the innermost derivative argument, and no expandable derivatives, this can be set to false for better discretization performance at the cost of generality, if you perform these transformations yourself.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"use_ODAE: MethodOfLines will automatically make use of ODAEProblem where relevant, which improves performance for DAEs (as discretized PDEs are in general), if this is set to true. Defaults to false.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Any unrecognized keyword arguments will be passed to the ODEProblem constructor, see its documentation for available options.","category":"page"},{"location":"tutorials/icbc_sampled/#Initial-and-Boundary-Conditions-with-sampled/measured-Data","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"","category":"section"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Initial and boundary conditions are sometimes applied with measured data that is itself pre-discretized. In order to use such data it is recommended to leverage Interpolations.jl, or DataInterpolations.jl, for better dealing with possibly noisy data (currently limited to 1D). To create a callable effectively continuous function, for example (from the Interpolations.jl docs):","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"1D:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"using Interpolations\n\nA_x = 1.:2.:40.\nA = [log10(x) for x in A_x]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp1 = scale(itp, A_x)\nsitp1(3.) # exactly log10(3.)\nsitp1(3.5) # approximately log10(3.5)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Multidimensional:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"using Interpolations \n\nA_x1 = 1:.1:10\nA_x2 = 1:.5:20\nf(x1, x2) = log10(x1+x2)\nA = [f(x1,x2) for x1 in A_x1, x2 in A_x2]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp2 = scale(itp, A_x1, A_x2)\nsitp2(5., 10.) # exactly log10(5 + 10)\nsitp2(5.6, 7.1) # approximately log10(5.6 + 7.1)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Then, register the functions with ModelingToolkit:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"sitp1_f(x) = sitp1(x)\nsitp2_f(x, y) = sitp2(x, y)\n@register_symbolic sitp1_f(y)\n@register_symbolic sitp2_f(x, y)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Then as a BC or IC:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"bcs = [u(0, x, y) ~ sitp2_f(x, y),\n       u(t, 0, y) ~ sitp1_f(y),\n       ...\n       ]","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Note that the measured data need not be measured on the same grid as will be generated for the discretization in MethodOfLines.jl, as long as it is defined upon the whole simulation domain it will be automatically re-sampled.","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"If you are using an edge_align grid, your interpolation will need to be defined ±dx/2 above and below the edges of the simulation domain where dx is the step size in the direction of that edge. Extrapolation may prove useful here.","category":"page"},{"location":"tutorials/heatss/#Steady-State-Heat-Equation-No-Time-Dependance-NonlinearProblem","page":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","title":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","text":"","category":"section"},{"location":"tutorials/heatss/","page":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","title":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","text":"Sometimes it is desirable to solve an equation that has no time evolution, such as the steady state heat equation:","category":"page"},{"location":"tutorials/heatss/","page":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","title":"Steady State Heat Equation - No Time Dependance - NonlinearProblem","text":"using ModelingToolkit, MethodOfLines, DomainSets, NonlinearSolve\n\n@parameters x y\n@variables u(..)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\neq = Dxx(u(x, y)) + Dyy(u(x, y)) ~ 0\n\nbcs = [u(0, y) ~ x * y,\n       u(1, y) ~ x * y,\n       u(x, 0) ~ x * y,\n       u(x, 1) ~ x * y]\n\n\n# Space and time domains\ndomains = [x ∈ Interval(0.0, 1.0),\n           y ∈ Interval(0.0, 1.0)]\n\n@named pdesys = PDESystem([eq], bcs, domains, [x, y], [u(x, y)])\n\ndx = 0.1\ndy = 0.1\n\n# Note that we pass in `nothing` for the time variable `t` here since we\n# are creating a stationary problem without a dependence on time, only space.\ndiscretization = MOLFiniteDifference([x => dx, y => dy], nothing, approx_order=2)\n\nprob = discretize(pdesys, discretization)\nsol = NonlinearSolve.solve(prob, NewtonRaphson())\n\nu_sol = sol[u(x, y)]\n\nusing Plots\n\nheatmap(sol[x], sol[y], u_sol, xlabel=\"x values\", ylabel=\"y values\",\n        title=\"Steady State Heat Equation\")","category":"page"},{"location":"tutorials/params/#Adding-parameters","page":"Adding parameters","title":"Adding parameters","text":"","category":"section"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"We can also build up more complicated systems with multiple dependent variables and parameters as follows","category":"page"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n@parameters t x\n@parameters Dn, Dp\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\neqs  = [Dt(u(t,x)) ~ Dn * Dxx(u(t,x)) + u(t,x)*v(t,x), \n        Dt(v(t,x)) ~ Dp * Dxx(v(t,x)) - u(t,x)*v(t,x)]\nbcs = [u(0,x) ~ sin(pi*x/2),\n       v(0,x) ~ sin(pi*x/2),\n       u(t,0) ~ 0.0, Dx(u(t,1)) ~ 0.0,\n       v(t,0) ~ 0.0, Dx(v(t,1)) ~ 0.0]\n\ndomains = [t ∈ Interval(0.0,1.0),\n           x ∈ Interval(0.0,1.0)]\n\n@named pdesys = PDESystem(eqs,bcs,domains,[t,x],[u(t,x),v(t,x)],[Dn=>0.5, Dp=>2])\n\ndiscretization = MOLFiniteDifference([x=>0.1],t)\n\nprob = discretize(pdesys,discretization) # This gives an ODEProblem since it's time-dependent\n\nsol = solve(prob,Tsit5())\n\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\n\nsolu = sol[u(t, x)]\nsolv = sol[v(t, x)]\n\nusing Plots\n\nanim = @animate for i in 1:length(t)\n    p1 = plot(discrete_x, solu[i, :], label=\"u, t=$(discrete_t[i])[1:9] \"; legend=false, xlabel=\"x\",ylabel=\"u\",ylim=[0,1])\n    p2 = plot(discrete_x, solv[i, :], label=\"v, t=$(discrete_t[i])\"; legend=false, xlabel=\"x\", ylabel=\"v\",ylim=[0, 1])\n    plot(p1, p2)\nend\ngif(anim, \"plot.gif\",fps=30)","category":"page"},{"location":"tutorials/params/#Remake-with-different-parameter-values","page":"Adding parameters","title":"Remake with different parameter values","text":"","category":"section"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"The system does not need to be re-discretized every time we want to plot with different parameters, the system can be remade with new parameters with remake. See the ModelingToolkit.jl docs for more ways to manipulate a prob post discretization.","category":"page"},{"location":"tutorials/params/","page":"Adding parameters","title":"Adding parameters","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n@parameters t x\n@parameters Dn, Dp\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\neqs  = [Dt(u(t, x)) ~ Dn * Dxx(u(t, x)) + u(t, x)*v(t,x),\n        Dt(v(t, x)) ~ Dp * Dxx(v(t, x)) - u(t, x)*v(t,x)]\nbcs = [u(0, x) ~ sin(pi*x/2),\n       v(0, x) ~ sin(pi*x/2),\n       u(t, 0) ~ 0.0, Dx(u(t, 1)) ~ 0.0,\n       v(t, 0) ~ 0.0, Dx(v(t, 1)) ~ 0.0]\n\ndomains = [t ∈ Interval(0.0, 1.0),\n           x ∈ Interval(0.0, 1.0)]\n\n@named pdesys = PDESystem(eqs, bcs, domains,[t, x], [u(t, x), v(t, x)], [Dn=>0.5, Dp=>2.0])\n\ndiscretization = MOLFiniteDifference([x=>0.1], t)\n\nprob = discretize(pdesys,discretization) # This gives an ODEProblem since it's time-dependent\n\nsols = []\nfor (Dnval, Dpval) in zip(rand(10), rand(10))\n    newprob = remake(prob, p = [Dnval, Dpval])\n    push!(sols, solve(newprob, Tsit5()));\nend\n\n\nusing Plots\nfor (j, sol) in enumerate(sols)\n    discrete_x = sol[x]\n    discrete_t = sol[t]\n    solu = sol[u(t, x)]\n    solv = sol[v(t, x)]\n    anim = @animate for i in 1:length(discrete_t)\n        p1 = plot(discrete_x, solu[i, :], label=\"u, t=$(discrete_t[i])\"; legend=false, xlabel=\"x\",ylabel=\"u\",ylim=[0,1])\n        p2 = plot(discrete_x, solv[i, :], label=\"v, t=$(discrete_t[i])\"; legend=false, xlabel=\"x\", ylabel=\"v\",ylim=[0, 1])\n        plot(p1, p2)\n    end\n    gif(anim, \"plot_$j.gif\",fps=10)\nend\n","category":"page"},{"location":"#index","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"MethodOfLines.jl is a Julia package for automated finite difference discretization of symbolicaly-defined PDEs in N dimensions.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"It uses symbolic expressions for systems of partial differential equations as defined with ModelingToolkit.jl, and Interval from DomainSets.jl to define the space(time) over which the simulation runs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"It is a SciML \"Discretizer\" package, a class of packages which export the methods:","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"discretize(sys::PDESystem, disc::D) where {D <: AbstractDiscretization}, which returns an AbstractSciMLProblem to be solved with the ecosystem's solvers.\nsymbolic_discretize(sys::PDESystem, disc::D) where {D <: AbstractDiscretization}, which returns an AbstractSystem from ModelingToolkit.jl.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"A Discretizer also optionally provides automatic solution wrapping, for easing the retrieval of shaped portions of the solution, and multi dimensional interpolations. This feature is provided by MethodOfLines.jl, see the solution interface page for more information.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"The AbstractDiscretization that MethodOfLines.jl provides is the MOLFiniteDifference, see its documentation for full information about interface options.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"The package's handling is quite general, it is recommended to try out your system of equations and post an issue if you run in to trouble. If you want to solve it, we want to support it.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Issues with questions on usage are also welcome as they help us improve the docs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"See here for a full tutorial, involving the Brusselator equation.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Allowable terms in the system include, but are not limited to","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Advection\nDiffusion\nReaction\nNonlinear Diffusion\nSpherical laplacian\nAny Julia function of the symbolic parameters/dependant variables and other parameters in the environment that's defined on the whole domain. Note that more complicated functions may require registration with @register, see the ModelingToolkit.jl docs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Boundary conditions include, but are not limited to:","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Dirichlet\nNeumann (can also include time derivative)\nRobin (can also include time derivative)\nPeriodic\nAny Julia function that returns a number","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"At the moment the centered difference, upwind difference, nonlinear laplacian and spherical laplacian schemes are implemented. If you know of a scheme with better stability or accuracy in any specific case, please post an issue with a link to a paper.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Due to an implementation detail, the maximum derivative order that can be discretized by MOL is div(typemax(Int), 2), in 64 bit 4611686018427387903. We hope that this is enough for your purposes!","category":"page"},{"location":"#Installation","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"Installation","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Assuming that you already have Julia correctly installed, it suffices to import Optimization.jl in the standard way:","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"import Pkg\nPkg.add(\"MethodOfLines\")","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"The packages relevant to the core functionality of Optimization.jl will be imported accordingly and, in most cases, you do not have to worry about the manual installation of dependencies. However, you will need to add the specific optimizer packages.","category":"page"},{"location":"#Contributing","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"Contributing","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#limitations","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"Known Limitations","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"At the moment the package is able to discretize almost any system, with some assumptions listed below","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"That the grid is cartesian.\nBoundary conditions in time are supplied as initial conditions, not at the end of the simulation interal. If your system requires a final condition, please use a change of variables to rectify this. This is unlikely to change due to upstream constraints.\nIntergral equations are not supported.\nThat dependant variables always have the same argument signature, except in BCs.\nThat higher order interface bcs are accompanied by a simple interface of the form u1(t, x_int) ~ u2(t, x_int)\nThat boundary conditions do not contain references to derivatives which are not in the direction of the boundary, except in time.\nThat odd order derivatives do not multiply or divide each other, unless the WENO Scheme is used.\nThat the WENO scheme must be used when there are mixed derivatives.\nNote that the WENO Scheme is often unstable in more than 1 spatial dimension due to difficulties with boundary handling, this can be avoided if you supply 2 or more bcs per boundary in the dimension along which an advection term acts.","category":"page"},{"location":"#Reproducibility","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"</details>","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"</details>","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"</details>","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning","text":"\">project</a> file.","category":"page"}]
}
