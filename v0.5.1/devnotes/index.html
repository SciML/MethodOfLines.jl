<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Notes for Developers: Implement a Scheme · MethodOfLines.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://methodoflines.sciml.ai/stable/devnotes/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MethodOfLines.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MethodOfLines.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/brusselator/">Tutorial</a></li><li><a class="tocitem" href="../tutorials/heat/">Solving the Heat Equation</a></li><li><a class="tocitem" href="../tutorials/params/">Adding parameters</a></li><li><a class="tocitem" href="../tutorials/heatss/">Steady State Heat Equation - No Time Dependance - NonlinearProblem</a></li><li><a class="tocitem" href="../tutorials/sispde/">Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model</a></li><li><a class="tocitem" href="../tutorials/icbc_sampled/">Initial and Boundary Conditions with sampled/measured Data</a></li></ul></li><li><a class="tocitem" href="../MOLFiniteDifference/">MOLFiniteDifference</a></li><li><a class="tocitem" href="../solutions/">Solution Interface - PDESolutions</a></li><li><a class="tocitem" href="../get_grid/">Grid and Solution Retrieval - Deprecated</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../advection_schemes/">Advection Schemes</a></li><li><a class="tocitem" href="../nonuniform/">Non-Uniform Rectilinear Grids</a></li><li><a class="tocitem" href="../curvilinear_grids/">Curvilinear Grids</a></li><li><a class="tocitem" href="../howitworks/">How it Works</a></li><li class="is-active"><a class="tocitem" href>Notes for Developers: Implement a Scheme</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Adding-new-finite-difference-schemes"><span>Adding new finite difference schemes</span></a></li><li><a class="tocitem" href="#Inspecting-generated-code"><span>Inspecting generated code</span></a></li></ul></li><li><span class="tocitem">Generated Examples</span><ul><li><a class="tocitem" href="../generated/bruss_code/">Generated Code for the Brusselator Equation</a></li><li><a class="tocitem" href="../generated/bruss_ode_eqs/">Generated ODE system for the Brusselator Equation</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/discretization/">Discretization</a></li><li><a class="tocitem" href="../api/utils/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Notes for Developers: Implement a Scheme</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Notes for Developers: Implement a Scheme</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/MethodOfLines.jl/blob/master/docs/src/devnotes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Notes-for-developers"><a class="docs-heading-anchor" href="#Notes-for-developers">Notes for developers</a><a id="Notes-for-developers-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-for-developers" title="Permalink"></a></h1><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>First, fork the repo and clone it locally.</p><p>Then, type in the REPL</p><pre><code class="nohighlight hljs">julia&gt;] dev /path/to/your/repo
julia&gt;] activate MethodOfLines</code></pre><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>MethodOfLines.jl makes heavy use of <a href="https://symbolics.juliasymbolics.org/dev/"><code>Symbolics.jl</code></a> and <a href="https://symbolicutils.juliasymbolics.org"><code>SymbolicUtils.jl</code></a>, especially the replacement rules from the latter.</p><p>Take a look at <a href="https://github.com/SciML/MethodOfLines.jl/blob/master/src/MOL_discretization.jl"><code>src/discretization/MOL_discretization.jl</code></a> to get a high level overview of how the discretization works. A more consise description can be found <a href="../howitworks/#hiw">here</a>. Feel free to post an issue if you would like help understanding anything, or want to know developer opinions on the best way to go about implementing something.</p><h2 id="Adding-new-finite-difference-schemes"><a class="docs-heading-anchor" href="#Adding-new-finite-difference-schemes">Adding new finite difference schemes</a><a id="Adding-new-finite-difference-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-new-finite-difference-schemes" title="Permalink"></a></h2><p>If you know of a finite difference scheme which is better than what is currently implemented, please first post an issue with a link to a paper.</p><p>A replacement rule is generated for each term which has a more specific higher stability/accuracy finite difference scheme than the general central difference, which represents a base case.</p><p>Take a look at <a href="https://github.com/SciML/MethodOfLines.jl/blob/243252a595ed2af549d98270bd3b8ca5e3f93d69/src/discretization/generate_finite_difference_rules.jl"><code>src/discretization/generate_finite_difference_rules.jl</code></a> to see where the replacement rules are generated. Implemented schemes can be found in <code>/src/discretization/schemes</code>. Have a look at some of the already implemented examples there; read about the <a href="https://symbolicutils.juliasymbolics.org/rewrite/"><code>@rule</code> macro</a> from <code>SymbolicUtils.jl</code>, if you haven&#39;t already. Note that the order that the rules are applied is important; there may be schemes that are applied first that are special cases of more general rules, for example the sphrical laplacian is a special case of the nonlinear laplacian.</p><p>First terms are split, isolating particular cases. Then, rules are generated and applied.  </p><p>Identify a rule which will match your case, then write a function that will handle how to apply that scheme for each index in the interior, for each combination of independant and dependant variables. </p><p>This should be a function of the current index <code>II::CartesianIndex</code>, an independent variable <code>x</code> which represents the direction of the derivative, and a dependent variable <code>u</code>, which is the variable of which the derivative will be taken. The discrete representation of <code>u</code> is found in <code>s.discvars[u]</code>, which is an array with the same number of spatial dimensions as <code>u</code>, each index a symbol representing the discretized <code>u</code> at that index. Using this, and cartesian index offsets from <code>II</code>, create a finite difference/volume symbolic expression for the approximation of the derivative form you are trying to discretize. This should be returned.</p><p>For example, the following is a simple rule and function that would discretize derivatives of each dependent variable <code>u</code>in each dependent variable <code>x</code> with the second order central difference approximation:</p><pre><code class="language-julia hljs">#TODO: Add handling for cases where II is close to the boundaries
#TODO: Handle periodic boundary conditions
#TODO: Handle nonuniformly discretized `x`
function second_order_central_difference(II::CartesianIndex, s::DiscreteSpace, u, x)
    # Get which place `x` appears in `u`&#39;s arguments
    j = x2i(s, u, x)

    # Get a CartesianIndex of unit length that points in the direction of `x` e.g. CartesianIndex((1, 0, 0))
    I1 = unitindex(ndims(u, s), j) 

    discu = s.discvars[u]
    expr = (discu[II + I1] - discu[II - I1])/s.dx[x]

    return expr
end

# Note that indexmap is used along with the function `Idx` to create an equivalent index for the discrete form of `u`,
# which may have a different number of dimensions to `II`
function generate_central_difference_rules(II::CartesianIndex, s::DiscreteSpace, terms::Vector{&lt;:Term}, indexmap::Dict)
    rules = [[@rule Differential(x)(u) =&gt; second_order_central_difference(Idx(II, s, u, indexmap), s, u, x) for x in, params(u, x)] for u in depvars]

    rules = reduce(vcat, rules)

    # Parse the rules in to pairs that can be used with `substitute`, this can be copy pasted.
    rule_pairs = []
    for t in terms
        for r in rules
            if r(t) !== nothing
                push!(rule_pairs, t =&gt; r(t))
            end
        end
    end
    return rule_pairs
end</code></pre><p>Initially, don&#39;t worry if your scheme is only implemented for specific approximation orders, it is sufficient just to warn when the requested approximation order does not match that supplied by the scheme. We can work in future pull requests to generalize the scheme to higher approximation orders, where possible.</p><p>Finally, include your rules in the vector of rules to be used to replace terms in the PDE at this index, found <a href="https://github.com/SciML/MethodOfLines.jl/blob/949d0fee5e97c4adc59057460b3708161f776e9b/src/discretization/generate_finite_difference_rules.jl#L271">here</a>:</p><h2 id="Inspecting-generated-code"><a class="docs-heading-anchor" href="#Inspecting-generated-code">Inspecting generated code</a><a id="Inspecting-generated-code-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-generated-code" title="Permalink"></a></h2><p>To get the generated code for your system, use <code>code = ODEFunctionExpr(prob)</code>, or <code>MethodOfLines.generate_code(pdesys, discretization, &quot;my_generated_code_filename.jl&quot;)</code>, which will create a file called <code>my_generated_code_filename.jl</code> in <code>pwd()</code>. This can be useful to find errors in the discretization, but note that it is not recommended to use this code directly, calling <code>solve(prob, AppropriateSolver())</code> will handle this for you.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../howitworks/">« How it Works</a><a class="docs-footer-nextpage" href="../generated/bruss_code/">Generated Code for the Brusselator Equation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 12 October 2022 13:34">Wednesday 12 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
